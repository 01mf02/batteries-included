<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="BatLexing.html">
<link rel="next" href="BatLogger.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="BatArg" rel="Chapter" href="BatArg.html">
<link title="BatArray" rel="Chapter" href="BatArray.html">
<link title="BatAvlTree" rel="Chapter" href="BatAvlTree.html">
<link title="BatBase64" rel="Chapter" href="BatBase64.html">
<link title="BatBig_int" rel="Chapter" href="BatBig_int.html">
<link title="BatBigarray" rel="Chapter" href="BatBigarray.html">
<link title="BatBitSet" rel="Chapter" href="BatBitSet.html">
<link title="BatBool" rel="Chapter" href="BatBool.html">
<link title="BatBuffer" rel="Chapter" href="BatBuffer.html">
<link title="BatCamomile" rel="Chapter" href="BatCamomile.html">
<link title="BatChar" rel="Chapter" href="BatChar.html">
<link title="BatCharEncodings" rel="Chapter" href="BatCharEncodings.html">
<link title="BatCharParser" rel="Chapter" href="BatCharParser.html">
<link title="BatComplex" rel="Chapter" href="BatComplex.html">
<link title="BatConcurrent" rel="Chapter" href="BatConcurrent.html">
<link title="BatDigest" rel="Chapter" href="BatDigest.html">
<link title="BatDllist" rel="Chapter" href="BatDllist.html">
<link title="BatDynArray" rel="Chapter" href="BatDynArray.html">
<link title="BatEnum" rel="Chapter" href="BatEnum.html">
<link title="BatFile" rel="Chapter" href="BatFile.html">
<link title="BatFloat" rel="Chapter" href="BatFloat.html">
<link title="BatFormat" rel="Chapter" href="BatFormat.html">
<link title="BatGc" rel="Chapter" href="BatGc.html">
<link title="BatGenlex" rel="Chapter" href="BatGenlex.html">
<link title="BatGlobal" rel="Chapter" href="BatGlobal.html">
<link title="BatHashtbl" rel="Chapter" href="BatHashtbl.html">
<link title="BatIMap" rel="Chapter" href="BatIMap.html">
<link title="BatIO" rel="Chapter" href="BatIO.html">
<link title="BatISet" rel="Chapter" href="BatISet.html">
<link title="BatInnerIO" rel="Chapter" href="BatInnerIO.html">
<link title="BatInnerWeaktbl" rel="Chapter" href="BatInnerWeaktbl.html">
<link title="BatInt" rel="Chapter" href="BatInt.html">
<link title="BatInt32" rel="Chapter" href="BatInt32.html">
<link title="BatInt64" rel="Chapter" href="BatInt64.html">
<link title="BatInterfaces" rel="Chapter" href="BatInterfaces.html">
<link title="BatLazyList" rel="Chapter" href="BatLazyList.html">
<link title="BatLexing" rel="Chapter" href="BatLexing.html">
<link title="BatList" rel="Chapter" href="BatList.html">
<link title="BatLogger" rel="Chapter" href="BatLogger.html">
<link title="BatMap" rel="Chapter" href="BatMap.html">
<link title="BatMarshal" rel="Chapter" href="BatMarshal.html">
<link title="BatMonad" rel="Chapter" href="BatMonad.html">
<link title="BatMultiPMap" rel="Chapter" href="BatMultiPMap.html">
<link title="BatMutex" rel="Chapter" href="BatMutex.html">
<link title="BatNativeint" rel="Chapter" href="BatNativeint.html">
<link title="BatNum" rel="Chapter" href="BatNum.html">
<link title="BatNumber" rel="Chapter" href="BatNumber.html">
<link title="BatOo" rel="Chapter" href="BatOo.html">
<link title="BatOptParse" rel="Chapter" href="BatOptParse.html">
<link title="BatOption" rel="Chapter" href="BatOption.html">
<link title="BatPMap" rel="Chapter" href="BatPMap.html">
<link title="BatPSet" rel="Chapter" href="BatPSet.html">
<link title="BatPair" rel="Chapter" href="BatPair.html">
<link title="BatParserCo" rel="Chapter" href="BatParserCo.html">
<link title="BatPathGen" rel="Chapter" href="BatPathGen.html">
<link title="BatPervasives" rel="Chapter" href="BatPervasives.html">
<link title="BatPrint" rel="Chapter" href="BatPrint.html">
<link title="BatPrintexc" rel="Chapter" href="BatPrintexc.html">
<link title="BatPrintf" rel="Chapter" href="BatPrintf.html">
<link title="BatQueue" rel="Chapter" href="BatQueue.html">
<link title="BatRMutex" rel="Chapter" href="BatRMutex.html">
<link title="BatRandom" rel="Chapter" href="BatRandom.html">
<link title="BatRef" rel="Chapter" href="BatRef.html">
<link title="BatRefList" rel="Chapter" href="BatRefList.html">
<link title="BatResult" rel="Chapter" href="BatResult.html">
<link title="BatReturn" rel="Chapter" href="BatReturn.html">
<link title="BatRope" rel="Chapter" href="BatRope.html">
<link title="BatScanf" rel="Chapter" href="BatScanf.html">
<link title="BatSeq" rel="Chapter" href="BatSeq.html">
<link title="BatSet" rel="Chapter" href="BatSet.html">
<link title="BatStack" rel="Chapter" href="BatStack.html">
<link title="BatStd" rel="Chapter" href="BatStd.html">
<link title="BatStr" rel="Chapter" href="BatStr.html">
<link title="BatStream" rel="Chapter" href="BatStream.html">
<link title="BatString" rel="Chapter" href="BatString.html">
<link title="BatSubstring" rel="Chapter" href="BatSubstring.html">
<link title="BatSys" rel="Chapter" href="BatSys.html">
<link title="BatUChar" rel="Chapter" href="BatUChar.html">
<link title="BatUCharParser" rel="Chapter" href="BatUCharParser.html">
<link title="BatUTF8" rel="Chapter" href="BatUTF8.html">
<link title="BatUnit" rel="Chapter" href="BatUnit.html">
<link title="BatUnix" rel="Chapter" href="BatUnix.html">
<link title="BatValue_printer" rel="Chapter" href="BatValue_printer.html">
<link title="BatVect" rel="Chapter" href="BatVect.html">
<link title="Batteries" rel="Chapter" href="Batteries.html">
<link title="Batteries_config" rel="Chapter" href="Batteries_config.html">
<link title="Batteries_print" rel="Chapter" href="Batteries_print.html">
<link title="Batteries_uni" rel="Chapter" href="Batteries_uni.html"><link title="Base operations" rel="Section" href="#6_Baseoperations">
<link title="Constructors" rel="Section" href="#6_Constructors">
<link title="Iterators" rel="Section" href="#6_Iterators">
<link title="Iterators on two lists" rel="Section" href="#6_Iteratorsontwolists">
<link title="List scanning" rel="Section" href="#6_Listscanning">
<link title="List searching" rel="Section" href="#6_Listsearching">
<link title="Association lists" rel="Section" href="#6_Associationlists">
<link title="List transformations" rel="Section" href="#6_Listtransformations">
<link title="BatEnum functions" rel="Section" href="#6_BatEnumfunctions">
<link title="List of pairs" rel="Section" href="#6_Listofpairs">
<link title="Utilities" rel="Section" href="#6_Utilities">
<link title="Boilerplate code" rel="Section" href="#6_Boilerplatecode">
<link title="Obsolete functions" rel="Section" href="#6_Obsoletefunctions">
<link title="Override modules" rel="Section" href="#6_Overridemodules">
<link title="Printing" rel="Subsection" href="#7_Printing">
<title>BatList</title>
</head>
<body>
<div class="navbar"><a href="BatLexing.html">Previous</a>
&nbsp;<a href="index.html">Up</a>
&nbsp;<a href="BatLogger.html">Next</a>
</div>
<center><h1>Module <a href="type_BatList.html">BatList</a></h1></center>
<br>
<pre><span class="keyword">module</span> BatList: <code class="code">sig</code> <a href="BatList.html">..</a> <code class="code">end</code></pre>Additional and modified functions for lists.
<p>

    The OCaml standard library provides a module for list functions.
    This BatList module can be used to extend the List module or
    as a standalone module. It provides new functions and modify
    the behavior of some other ones (in particular all functions
    are now <b>tail-recursive</b>).
<p>

    The following functions have the same behavior as the <code class="code">List</code>
    module ones but are tail-recursive: <code class="code">map</code>, <code class="code">append</code>, <code class="code">concat</code>,
    <code class="code">flatten</code>, <code class="code">fold_right</code>, <code class="code">remove_assoc</code>, <code class="code">remove_assq</code>,
    <code class="code">split</code>. That means they will not
    cause a <code class="code">Stack_overflow</code> when used on very long list.
<p>

    The implementation might be a little more slow in bytecode,
    but compiling in native code will not affect performances. 
<p>

    This module extends Stdlib's
    <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html">List</a>
    module, go there for documentation on the rest of the functions
    and types.<br>
<hr width="100%">
<pre><span class="keyword">type</span> <a name="TYPEt"></a><code class="type">'a</code> t = <code class="type">'a list</code> </pre>
<div class="info">
List operations.
<p>
The type of lists<br>
<b>Author(s):</b> Xavier Leroy (base module), Brian Hurt, Nicolas Cannasse, Richard W.M. Jones, David Teller<br>
</div>

<pre><span class="keyword">include</span> <a href="BatEnum.Enumerable.html">BatEnum.Enumerable</a></pre>
<pre><span class="keyword">include</span> <a href="BatInterfaces.Mappable.html">BatInterfaces.Mappable</a></pre>
<br>
<a name="6_Baseoperations"></a>
<h6>Base operations</h6><br>
<pre><span class="keyword">val</span> <a name="VALis_empty"></a>is_empty : <code class="type">'a list -> bool</code></pre><div class="info">
<code class="code">is_empty e</code> returns true if <code class="code">e</code> does not contains any element.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcons"></a>cons : <code class="type">'a -> 'a list -> 'a list</code></pre><div class="info">
<code class="code">cons h t</code> returns the list starting with <code class="code">h</code> and continuing as <code class="code">t</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALfirst"></a>first : <code class="type">'a list -> 'a</code></pre><div class="info">
Returns the first element of the list, or raise <code class="code">Empty_list</code> if
	      the list is empty (similar to <code class="code">hd</code>).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALlast"></a>last : <code class="type">'a list -> 'a</code></pre><div class="info">
Returns the last element of the list, or raise <code class="code">Empty_list</code> if
	      the list is empty. This function takes linear time.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALat"></a>at : <code class="type">'a list -> int -> 'a</code></pre><div class="info">
<code class="code">at l n</code> returns the n-th element of the list <code class="code">l</code> or raise
	      <code class="code">Invalid_index</code> is the index is outside of <code class="code">l</code> bounds.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALappend"></a>append : <code class="type">'a list -> 'a list -> 'a list</code></pre><div class="info">
Catenate two lists.  Same function as the infix operator <code class="code">@</code>.
	      Tail-recursive (length of the first argument).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconcat"></a>concat : <code class="type">'a list list -> 'a list</code></pre><div class="info">
Concatenate a list of lists.  The elements of the argument are all
	      concatenated together (in the same order) to give the result.
	      Tail-recursive
	      (length of the argument + length of the longest sub-list).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALflatten"></a>flatten : <code class="type">'a list list -> 'a list</code></pre><div class="info">
Same as <code class="code">concat</code>.<br>
</div>
<br>
<a name="6_Constructors"></a>
<h6>Constructors</h6><br>
<pre><span class="keyword">val</span> <a name="VALmake"></a>make : <code class="type">int -> 'a -> 'a list</code></pre><div class="info">
Similar to <code class="code">String.make</code>, <code class="code">make n x</code> returns a
	      list containing <code class="code">n</code> elements <code class="code">x</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALinit"></a>init : <code class="type">int -> (int -> 'a) -> 'a list</code></pre><div class="info">
Similar to <code class="code">Array.init</code>, <code class="code">init n f</code> returns the list containing
	      the results of (f 0),(f 1).... (f (n-1)).
	      Raise <code class="code">Invalid_arg "BatList.init"</code> if n &lt; 0.<br>
</div>
<br>
<a name="6_Iterators"></a>
<h6>Iterators</h6><br>
<pre><span class="keyword">val</span> <a name="VALiteri"></a>iteri : <code class="type">(int -> 'a -> 'b) -> 'a list -> unit</code></pre><div class="info">
<code class="code">iteri f l</code> will call <code class="code">(f 0 a0);(f 1 a1) ... (f n an)</code> where
	 <code class="code">a0..an</code> are the elements of the list <code class="code">l</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmap"></a>map : <code class="type">('a -> 'b) -> 'a list -> 'b list</code></pre><div class="info">
<code class="code">map f [a1; ...; an]</code> applies function <code class="code">f</code> to <code class="code">a1, ..., an</code>,
	      and builds the list <code class="code">[f a1; ...; f an]</code>
	      with the results returned by <code class="code">f</code>.  Tail-recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmapi"></a>mapi : <code class="type">(int -> 'a -> 'b) -> 'a list -> 'b list</code></pre><div class="info">
<code class="code">mapi f l</code> will build the list containing
	 <code class="code">(f 0 a0);(f 1 a1) ... (f n an)</code> where <code class="code">a0..an</code> are the elements of
	 the list <code class="code">l</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold_right"></a>fold_right : <code class="type">('a -> 'b -> 'b) -> 'a list -> 'b -> 'b</code></pre><div class="info">
<code class="code">List.fold_right f [a1; ...; an] b</code> is
	      <code class="code">f a1 (f a2 (... (f an b) ...))</code>.  Tail-recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALreduce"></a>reduce : <code class="type">('a -> 'a -> 'a) -> 'a list -> 'a</code></pre><div class="info">
<code class="code">List.reduce f h::t</code> is <code class="code">fold_left f h t</code>.<br>
<b>Raises</b> <code>Empty_list</code> on empty lists.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmax"></a>max : <code class="type">'a list -> 'a</code></pre><div class="info">
<code class="code">max l</code> returns the largest value in <code class="code">l</code> as judged by
	      <code class="code">Pervasives.compare</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALmin"></a>min : <code class="type">'a list -> 'a</code></pre><div class="info">
<code class="code">min l</code> returns the smallest value in <code class="code">l</code> as judged by
	      <code class="code">Pervasives.compare</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALsum"></a>sum : <code class="type">int list -> int</code></pre><div class="info">
<code class="code">sum l</code> returns the sum of the elements of <code class="code">l</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALfsum"></a>fsum : <code class="type">float list -> float</code></pre><div class="info">
<code class="code">sum l</code> returns the sum of the elements of <code class="code">l</code><br>
</div>
<br>
<a name="6_Iteratorsontwolists"></a>
<h6>Iterators on two lists</h6><br>
<pre><span class="keyword">val</span> <a name="VALiter2"></a>iter2 : <code class="type">('a -> 'b -> unit) -> 'a list -> 'b list -> unit</code></pre><div class="info">
<code class="code">List.iter2 f [a1; ...; an] [b1; ...; bn]</code> calls in turn
	      <code class="code">f a1 b1; ...; f an bn</code>.<br>
<b>Raises</b> <code>Different_list_size</code> if the two lists have
	      different lengths.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmap2"></a>map2 : <code class="type">('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list</code></pre><div class="info">
<code class="code">List.map2 f [a1; ...; an] [b1; ...; bn]</code> is
	      <code class="code">[f a1 b1; ...; f an bn]</code>.<br>
<b>Raises</b> <code>Different_list_size</code> if the two lists have
	      different lengths.  Tail-recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold_left2"></a>fold_left2 : <code class="type">('a -> 'b -> 'c -> 'a) -> 'a -> 'b list -> 'c list -> 'a</code></pre><div class="info">
<code class="code">List.fold_left2 f a [b1; ...; bn] [c1; ...; cn]</code> is
	      <code class="code">f (... (f (f a b1 c1) b2 c2) ...) bn cn</code>.<br>
<b>Raises</b> <code>Different_list_size</code> if the two lists have
	      different lengths.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold_right2"></a>fold_right2 : <code class="type">('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c</code></pre><div class="info">
<code class="code">List.fold_right2 f [a1; ...; an] [b1; ...; bn] c</code> is
	      <code class="code">f a1 b1 (f a2 b2 (... (f an bn c) ...))</code>.<br>
<b>Raises</b> <code>Different_list_size</code> if the two lists have
	      different lengths.  Tail-recursive.<br>
</div>
<br>
<a name="6_Listscanning"></a>
<h6>List scanning</h6><br>
<pre><span class="keyword">val</span> <a name="VALfor_all2"></a>for_all2 : <code class="type">('a -> 'b -> bool) -> 'a list -> 'b list -> bool</code></pre><div class="info">
Same as <code class="code">List.for_all</code>, but for a two-argument predicate.<br>
<b>Raises</b> <code>Invalid_argument</code> if the two lists have
	      different lengths.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALexists2"></a>exists2 : <code class="type">('a -> 'b -> bool) -> 'a list -> 'b list -> bool</code></pre><div class="info">
Same as <code class="code">List.exists</code>, but for a two-argument predicate.<br>
<b>Raises</b> <code>Invalid_argument</code> if the two lists have
	      different lengths.<br>
</div>
<br>
<a name="6_Listsearching"></a>
<h6>List searching</h6><br>
<pre><span class="keyword">val</span> <a name="VALfind_exn"></a>find_exn : <code class="type">('a -> bool) -> exn -> 'a list -> 'a</code></pre><div class="info">
<code class="code">find_exn p e l</code> returns the first element of <code class="code">l</code> such as <code class="code">p x</code>
	 returns <code class="code">true</code> or raises <code class="code">e</code> if such an element has not been found.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfindi"></a>findi : <code class="type">(int -> 'a -> bool) -> 'a list -> int * 'a</code></pre><div class="info">
<code class="code">findi p e l</code> returns the first element <code class="code">ai</code> of <code class="code">l</code> along with its
	 index <code class="code">i</code> such that <code class="code">p i ai</code> is true, or raises <code class="code">Not_found</code> if no
	 such element has been found.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfind_map"></a>find_map : <code class="type">('a -> 'b option) -> 'a list -> 'b</code></pre><div class="info">
<code class="code">find_map pred list</code> finds the first element of <code class="code">list</code> for which
            <code class="code">pred element</code> returns <code class="code">Some r</code>.  It returns <code class="code">r</code> immediately
            once found or raises <code class="code">Not_found</code> if no element matches the
            predicate.  See also <a href="BatList.html#VALfilter_map"><code class="code">BatList.filter_map</code></a>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALrfind"></a>rfind : <code class="type">('a -> bool) -> 'a list -> 'a</code></pre><div class="info">
<code class="code">rfind p l</code> returns the last element <code class="code">x</code> of <code class="code">l</code> such as <code class="code">p x</code> returns
	 <code class="code">true</code> or raises <code class="code">Not_found</code> if such element as not been found.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfilter"></a>filter : <code class="type">('a -> bool) -> 'a list -> 'a list</code></pre><div class="info">
<code class="code">filter p l</code> returns all the elements of the list <code class="code">l</code>
	      that satisfy the predicate <code class="code">p</code>.  The order of the elements
	      in the input list is preserved.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfilter_map"></a>filter_map : <code class="type">('a -> 'b option) -> 'a list -> 'b list</code></pre><div class="info">
<code class="code">filter_map f l</code> calls <code class="code">(f a0) (f a1).... (f an)</code> where <code class="code">a0..an</code> are
	 the elements of <code class="code">l</code>. It returns the list of elements <code class="code">bi</code> such as
	 <code class="code">f ai = Some bi</code> (when <code class="code">f</code> returns <code class="code">None</code>, the corresponding element of
	 <code class="code">l</code> is discarded).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfind_all"></a>find_all : <code class="type">('a -> bool) -> 'a list -> 'a list</code></pre><div class="info">
<code class="code">find_all</code> is another name for <code class="code">List.filter</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALpartition"></a>partition : <code class="type">('a -> bool) -> 'a list -> 'a list * 'a list</code></pre><div class="info">
<code class="code">partition p l</code> returns a pair of lists <code class="code">(l1, l2)</code>, where
	      <code class="code">l1</code> is the list of all the elements of <code class="code">l</code> that
	      satisfy the predicate <code class="code">p</code>, and <code class="code">l2</code> is the list of all the
	      elements of <code class="code">l</code> that do not satisfy <code class="code">p</code>.
	      The order of the elements in the input list is preserved.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALindex_of"></a>index_of : <code class="type">'a -> 'a list -> int option</code></pre><div class="info">
<code class="code">index_of e l</code> returns the index of the first occurrence of <code class="code">e</code>
	    in <code class="code">l</code>, or <code class="code">None</code> if there is no occurrence of <code class="code">e</code> in <code class="code">l</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALindex_ofq"></a>index_ofq : <code class="type">'a -> 'a list -> int option</code></pre><div class="info">
<code class="code">index_ofq e l</code> behaves as <code class="code">index_of e l</code> except it uses
	    physical equality<br>
</div>
<pre><span class="keyword">val</span> <a name="VALrindex_of"></a>rindex_of : <code class="type">'a -> 'a list -> int option</code></pre><div class="info">
<code class="code">rindex_of e l</code> returns the index of the last occurrence of <code class="code">e</code>
	    in <code class="code">l</code>, or <code class="code">None</code> if there is no occurrence of <code class="code">e</code> in <code class="code">l</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALrindex_ofq"></a>rindex_ofq : <code class="type">'a -> 'a list -> int option</code></pre><div class="info">
<code class="code">rindex_ofq e l</code> behaves as <code class="code">rindex_of e l</code> except it uses
	    physical equality<br>
</div>
<pre><span class="keyword">val</span> <a name="VALunique"></a>unique : <code class="type">?cmp:('a -> 'a -> bool) -> 'a list -> 'a list</code></pre><div class="info">
<code class="code">unique cmp l</code> returns the list <code class="code">l</code> without any duplicate element.
	 Default comparator ( = ) is used if no comparison function specified. 
<p>

	 This function takes O(n²) time.<br>
<b>See also</b> <code class="code">sort_unique</code> to save time in cases when reordering the list is acceptable<br>
</div>
<br>
<a name="6_Associationlists"></a>
<h6>Association lists</h6><br>
<pre><span class="keyword">val</span> <a name="VALassoc_inv"></a>assoc_inv : <code class="type">'a -> ('b * 'a) list -> 'b</code></pre><div class="info">
<code class="code">assoc_inv b l</code> returns the key associated with value <code class="code">b</code> in the list of
	      pairs <code class="code">l</code>. That is,
	      <code class="code">assoc b [ ...; (a,b); ...] = a</code>
	      if <code class="code">(a,b)</code> is the leftmost binding of <code class="code">a</code> in list <code class="code">l</code>.
	      Raise <code class="code">Not_found</code> if there is no key associated with <code class="code">b</code> in the
	      list <code class="code">l</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALremove_assoc"></a>remove_assoc : <code class="type">'a -> ('a * 'b) list -> ('a * 'b) list</code></pre><div class="info">
<code class="code">remove_assoc a l</code> returns the list of
	      pairs <code class="code">l</code> without the first pair with key <code class="code">a</code>, if any.
	      Tail-recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALremove_assq"></a>remove_assq : <code class="type">'a -> ('a * 'b) list -> ('a * 'b) list</code></pre><div class="info">
Same as <code class="code">List.remove_assoc</code>, but uses physical equality instead
	      of structural equality to compare keys.  Tail-recursive.<br>
</div>
<br>
<a name="6_Listtransformations"></a>
<h6>List transformations</h6><br>
<pre><span class="keyword">val</span> <a name="VALsplit_at"></a>split_at : <code class="type">int -> 'a list -> 'a list * 'a list</code></pre><div class="info">
<code class="code">split_at n l</code> returns two lists <code class="code">l1</code> and <code class="code">l2</code>, <code class="code">l1</code> containing the
	 first <code class="code">n</code> elements of <code class="code">l</code> and <code class="code">l2</code> the others. Raise <code class="code">Invalid_index</code> if
	 <code class="code">n</code> is outside of <code class="code">l</code> size bounds.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsplit_nth"></a>split_nth : <code class="type">int -> 'a list -> 'a list * 'a list</code></pre><div class="info">
Obsolete. As <code class="code">split_at</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALremove"></a>remove : <code class="type">'a list -> 'a -> 'a list</code></pre><div class="info">
<code class="code">remove l x</code> returns the list <code class="code">l</code> without the first element <code class="code">x</code> found
	 or returns  <code class="code">l</code> if no element is equal to <code class="code">x</code>. Elements are compared
	 using ( = ).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALremove_if"></a>remove_if : <code class="type">('a -> bool) -> 'a list -> 'a list</code></pre><div class="info">
<code class="code">remove_if cmp l</code> is similar to <code class="code">remove</code>, but with <code class="code">cmp</code> used
	 instead of ( = ).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALremove_all"></a>remove_all : <code class="type">'a list -> 'a -> 'a list</code></pre><div class="info">
<code class="code">remove_all l x</code> is similar to <code class="code">remove</code> but removes all elements that
	 are equal to <code class="code">x</code> and not only the first one.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtake"></a>take : <code class="type">int -> 'a list -> 'a list</code></pre><div class="info">
<code class="code">take n l</code> returns up to the <code class="code">n</code> first elements from list <code class="code">l</code>, if
	 available.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdrop"></a>drop : <code class="type">int -> 'a list -> 'a list</code></pre><div class="info">
<code class="code">drop n l</code> returns <code class="code">l</code> without the first <code class="code">n</code> elements, or the empty
	      list if <code class="code">l</code> have less than <code class="code">n</code> elements.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtake_while"></a>take_while : <code class="type">('a -> bool) -> 'a list -> 'a list</code></pre><div class="info">
<code class="code">takewhile f xs</code> returns the first elements of list <code class="code">xs</code>
	      which satisfy the predicate <code class="code">f</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdrop_while"></a>drop_while : <code class="type">('a -> bool) -> 'a list -> 'a list</code></pre><div class="info">
<code class="code">dropwhile f xs</code> returns the list <code class="code">xs</code> with the first
	      elements satisfying the predicate <code class="code">f</code> dropped.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALinterleave"></a>interleave : <code class="type">?first:'a -> ?last:'a -> 'a -> 'a list -> 'a list</code></pre><div class="info">
<code class="code">interleave ~first ~last sep [a1;a2;a3;...;an]</code> returns
	      <code class="code">first; a1; sep; a2; sep; a3; sep; ...; sep; an</code><br>
</div>
<br>
<a name="6_BatEnumfunctions"></a>
<h6>BatEnum functions</h6> 
<p>

	    Abstraction layer.<br>
<pre><span class="keyword">val</span> <a name="VALenum"></a>enum : <code class="type">'a list -> 'a <a href="BatEnum.html#TYPEt">BatEnum.t</a></code></pre><div class="info">
Returns an enumeration of the elements of a list. This enumeration may
	    be used to visit elements of the list in forward order (i.e. from the
	    first element to the last one)<br>
</div>
<pre><span class="keyword">val</span> <a name="VALof_enum"></a>of_enum : <code class="type">'a <a href="BatEnum.html#TYPEt">BatEnum.t</a> -> 'a list</code></pre><div class="info">
Build a list from an enumeration. In the result, elements appear in the
	    same order as they did in the source enumeration.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbackwards"></a>backwards : <code class="type">'a list -> 'a <a href="BatEnum.html#TYPEt">BatEnum.t</a></code></pre><div class="info">
Returns an enumeration of the elements of a list. This enumeration may
	    be used to visit elements of the list in backwards order (i.e. from the
	    last element to the first one)<br>
</div>
<pre><span class="keyword">val</span> <a name="VALof_backwards"></a>of_backwards : <code class="type">'a <a href="BatEnum.html#TYPEt">BatEnum.t</a> -> 'a list</code></pre><div class="info">
Build a list from an enumeration. The first element of the enumeration
	    becomes the last element of the list, the second element of the enumeration
	    becomes the second-to-last element of the list...<br>
</div>
<br>
<a name="6_Listofpairs"></a>
<h6>List of pairs</h6><br>
<pre><span class="keyword">val</span> <a name="VALsplit"></a>split : <code class="type">('a * 'b) list -> 'a list * 'b list</code></pre><div class="info">
Transform a list of pairs into a pair of lists:
	      <code class="code">split [(a1,b1); ...; (an,bn)]</code> is <code class="code">([a1; ...; an], [b1; ...; bn])</code>.
	      Tail-recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcombine"></a>combine : <code class="type">'a list -> 'b list -> ('a * 'b) list</code></pre><div class="info">
Transform a pair of lists into a list of pairs:
	      <code class="code">combine [a1; ...; an] [b1; ...; bn]</code> is
	      <code class="code">[(a1,b1); ...; (an,bn)]</code>.<br>
<b>Raises</b> <code>Different_list_size</code> if the two lists
	      have different lengths.  Tail-recursive.<br>
</div>
<br>
<a name="6_Utilities"></a>
<h6>Utilities</h6><br>
<pre><span class="keyword">val</span> <a name="VALmake_compare"></a>make_compare : <code class="type">('a -> 'a -> int) -> 'a list -> 'a list -> int</code></pre><div class="info">
<code class="code">make_compare c</code> generates the lexicographical order on lists
	      induced by <code class="code">c</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALsort"></a>sort : <code class="type">?cmp:('a -> 'a -> int) -> 'a list -> 'a list</code></pre><div class="info">
Sort the list using optional comparator (by default <code class="code">compare</code>).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsort_unique"></a>sort_unique : <code class="type">('a -> 'a -> int) -> 'a list -> 'a list</code></pre><div class="info">
<code class="code">sort_unique cmp l</code> returns the list <code class="code">l</code> sorted and without any duplicate element. <code class="code">cmp</code> is a usual comparison function providing linear order. 
<p>

	  This function takes O(n log n) time.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALgroup"></a>group : <code class="type">('a -> 'a -> int) -> 'a list -> 'a list list</code></pre><div class="info">
<code class="code">group cmp l</code> returns list of groups and each group consists of elements judged equal by comparison function <code class="code">cmp</code>. Groups in the resulting list appear in order given by <code class="code">cmp</code>. All groups are always nonempty. <code class="code">group</code> returns <code class="code">[]</code> only if <code class="code">l</code> is empty.
<p>

For example <code class="code">group cmp [f;c;b;e;d;a]</code> can give <code class="code">[[a;b];[c];[d;e;f]]</code> if following conditions are met:
	  <code class="code">cmp a b = 0</code>, <code class="code">cmp b c = -1</code>, <code class="code">cmp c d = -1</code>, <code class="code">cmp d e = 0</code>,...<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcartesian_product"></a>cartesian_product : <code class="type">'a list -> 'b list -> ('a * 'b) list</code></pre><div class="info">
Different from <code class="code">List.combine</code>, this returns every pair
	      of elements formed out of the two lists.  <code class="code">cartesian_product
	      [a1; ...; an] [b1; ...; bn] = [(a1,b1);(a1,b2); ...;
	      (a1,bn); (a2,b1); ...; (an,bn)]</code>.  The lists can be of
	      unequal size.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALn_cartesian_product"></a>n_cartesian_product : <code class="type">'a list list -> 'a list list</code></pre><div class="info">
Given n lists, return the n-way cartesian product of
	      these lists.  Given <code class="code">[a;b];[c];[d;e;f]</code>, returns
	      <code class="code">[a;c;d];[a;c;e];[a;c;f];[b;c;d];[b;c;e];[b;c;f]</code>, all
	      ways of choosing one element from each input list.<br>
</div>
<br>
<a name="6_Boilerplatecode"></a>
<h6>Boilerplate code</h6><br>
<br>
<a name="7_Printing"></a>
<div class="h7">Printing</div><br>
<pre><span class="keyword">val</span> <a name="VALprint"></a>print : <code class="type">?first:string -><br>       ?last:string -><br>       ?sep:string -><br>       ('a <a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> -> 'b -> unit) -><br>       'a <a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> -> 'b list -> unit</code></pre><div class="info">
Print the contents of a list<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsprint"></a>sprint : <code class="type">?first:string -><br>       ?last:string -><br>       ?sep:string -> ('a <a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> -> 'b -> unit) -> 'b list -> string</code></pre><div class="info">
Using a string printer, print a list to a string (as sprintf vs. printf)<br>
</div>
<pre><span class="keyword">val</span> <a name="VALt_printer"></a>t_printer : <code class="type">'a <a href="BatValue_printer.html#TYPEt">BatValue_printer.t</a> -> 'a <a href="BatList.html#TYPEt">t</a> <a href="BatValue_printer.html#TYPEt">BatValue_printer.t</a></code></pre><br>
<a name="6_Obsoletefunctions"></a>
<h6>Obsolete functions</h6><br>
<pre><span class="keyword">val</span> <a name="VALnth"></a>nth : <code class="type">'a list -> int -> 'a</code></pre><div class="info">
Obsolete. As <code class="code">at</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtakewhile"></a>takewhile : <code class="type">('a -> bool) -> 'a list -> 'a list</code></pre><div class="info">
obsolete, as <a href="BatList.html#VALtake_while"><code class="code">BatList.take_while</code></a><br>
</div>
<pre><span class="keyword">val</span> <a name="VALdropwhile"></a>dropwhile : <code class="type">('a -> bool) -> 'a list -> 'a list</code></pre><div class="info">
obsolete, as <a href="BatList.html#VALdrop_while"><code class="code">BatList.drop_while</code></a><br>
</div>
<br>
<a name="6_Overridemodules"></a>
<h6>Override modules</h6><br>
<br>
The following modules replace functions defined in <code class="code">List</code> with functions
	   behaving slightly differently but having the same name. This is by design:
	   the functions meant to override the corresponding functions of <code class="code">List</code>.<br>
<pre><span class="keyword">module</span> <a href="BatList.Exceptionless.html">Exceptionless</a>: <code class="code">sig</code> <a href="BatList.Exceptionless.html">..</a> <code class="code">end</code></pre><div class="info">
Exceptionless counterparts for error-raising operations
</div>
<pre><span class="keyword">module</span> <a href="BatList.Labels.html">Labels</a>: <code class="code">sig</code> <a href="BatList.Labels.html">..</a> <code class="code">end</code></pre><div class="info">
Operations on <code class="code">List</code> with labels.
</div>
<pre><span class="keyword">val</span> <a name="VAL(@)"></a>(@) : <code class="type">'a list -> 'a list -> 'a list</code></pre><div class="info">
the new implementation for ( @ ) operator, see <code class="code">List.append</code>.<br>
</div>
</body></html>