<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Std.html">
<link rel="next" href="UCharParser.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="AvlTree" rel="Chapter" href="AvlTree.html">
<link title="Base64" rel="Chapter" href="Base64.html">
<link title="BatArg" rel="Chapter" href="BatArg.html">
<link title="BatArray" rel="Chapter" href="BatArray.html">
<link title="BatBig_int" rel="Chapter" href="BatBig_int.html">
<link title="BatBigarray" rel="Chapter" href="BatBigarray.html">
<link title="BatBool" rel="Chapter" href="BatBool.html">
<link title="BatBuffer" rel="Chapter" href="BatBuffer.html">
<link title="BatChar" rel="Chapter" href="BatChar.html">
<link title="BatComplex" rel="Chapter" href="BatComplex.html">
<link title="BatDigest" rel="Chapter" href="BatDigest.html">
<link title="BatFloat" rel="Chapter" href="BatFloat.html">
<link title="BatFormat" rel="Chapter" href="BatFormat.html">
<link title="BatGc" rel="Chapter" href="BatGc.html">
<link title="BatGenlex" rel="Chapter" href="BatGenlex.html">
<link title="BatHashtbl" rel="Chapter" href="BatHashtbl.html">
<link title="BatInt" rel="Chapter" href="BatInt.html">
<link title="BatInt32" rel="Chapter" href="BatInt32.html">
<link title="BatInt64" rel="Chapter" href="BatInt64.html">
<link title="BatLexing" rel="Chapter" href="BatLexing.html">
<link title="BatList" rel="Chapter" href="BatList.html">
<link title="BatMap" rel="Chapter" href="BatMap.html">
<link title="BatMarshal" rel="Chapter" href="BatMarshal.html">
<link title="BatMutex" rel="Chapter" href="BatMutex.html">
<link title="BatNativeint" rel="Chapter" href="BatNativeint.html">
<link title="BatNum" rel="Chapter" href="BatNum.html">
<link title="BatOo" rel="Chapter" href="BatOo.html">
<link title="BatPervasives" rel="Chapter" href="BatPervasives.html">
<link title="BatPrintexc" rel="Chapter" href="BatPrintexc.html">
<link title="BatPrintf" rel="Chapter" href="BatPrintf.html">
<link title="BatQueue" rel="Chapter" href="BatQueue.html">
<link title="BatRandom" rel="Chapter" href="BatRandom.html">
<link title="BatScanf" rel="Chapter" href="BatScanf.html">
<link title="BatSet" rel="Chapter" href="BatSet.html">
<link title="BatStack" rel="Chapter" href="BatStack.html">
<link title="BatStr" rel="Chapter" href="BatStr.html">
<link title="BatStream" rel="Chapter" href="BatStream.html">
<link title="BatString" rel="Chapter" href="BatString.html">
<link title="BatSys" rel="Chapter" href="BatSys.html">
<link title="BatUChar" rel="Chapter" href="BatUChar.html">
<link title="BatUTF8" rel="Chapter" href="BatUTF8.html">
<link title="BatUnit" rel="Chapter" href="BatUnit.html">
<link title="BatUnix" rel="Chapter" href="BatUnix.html">
<link title="BitSet" rel="Chapter" href="BitSet.html">
<link title="CharEncodings" rel="Chapter" href="CharEncodings.html">
<link title="CharParser" rel="Chapter" href="CharParser.html">
<link title="Concurrent" rel="Chapter" href="Concurrent.html">
<link title="Dllist" rel="Chapter" href="Dllist.html">
<link title="DynArray" rel="Chapter" href="DynArray.html">
<link title="Enum" rel="Chapter" href="Enum.html">
<link title="File" rel="Chapter" href="File.html">
<link title="Global" rel="Chapter" href="Global.html">
<link title="IMap" rel="Chapter" href="IMap.html">
<link title="IO" rel="Chapter" href="IO.html">
<link title="ISet" rel="Chapter" href="ISet.html">
<link title="InnerIO" rel="Chapter" href="InnerIO.html">
<link title="InnerWeaktbl" rel="Chapter" href="InnerWeaktbl.html">
<link title="Interfaces" rel="Chapter" href="Interfaces.html">
<link title="LazyList" rel="Chapter" href="LazyList.html">
<link title="Logger" rel="Chapter" href="Logger.html">
<link title="Monad" rel="Chapter" href="Monad.html">
<link title="MultiPMap" rel="Chapter" href="MultiPMap.html">
<link title="Number" rel="Chapter" href="Number.html">
<link title="OptParse" rel="Chapter" href="OptParse.html">
<link title="Option" rel="Chapter" href="Option.html">
<link title="PMap" rel="Chapter" href="PMap.html">
<link title="PSet" rel="Chapter" href="PSet.html">
<link title="ParserCo" rel="Chapter" href="ParserCo.html">
<link title="PathGen" rel="Chapter" href="PathGen.html">
<link title="Print" rel="Chapter" href="Print.html">
<link title="RMutex" rel="Chapter" href="RMutex.html">
<link title="Ref" rel="Chapter" href="Ref.html">
<link title="RefList" rel="Chapter" href="RefList.html">
<link title="Result" rel="Chapter" href="Result.html">
<link title="Return" rel="Chapter" href="Return.html">
<link title="Rope" rel="Chapter" href="Rope.html">
<link title="Seq" rel="Chapter" href="Seq.html">
<link title="Std" rel="Chapter" href="Std.html">
<link title="Substring" rel="Chapter" href="Substring.html">
<link title="UCharParser" rel="Chapter" href="UCharParser.html">
<link title="Value_printer" rel="Chapter" href="Value_printer.html">
<link title="Vect" rel="Chapter" href="Vect.html"><title>Substring</title>
</head>
<body>
<div class="navbar"><a href="Std.html">Previous</a>
&nbsp;<a href="index.html">Up</a>
&nbsp;<a href="UCharParser.html">Next</a>
</div>
<center><h1>Module <a href="type_Substring.html">Substring</a></h1></center>
<br>
<pre><span class="keyword">module</span> Substring: <code class="code">sig</code> <a href="Substring.html">..</a> <code class="code">end</code></pre><code class="code">Substring.t</code> is the type of substrings of a basestring, an efficient 
   representation of a piece of a string.
<p>

   A substring (s,i,n) is valid if 0 &lt;= i &lt;= i+n &lt;= size s, 
                  or equivalently, 0 &lt;= i and 0 &lt;= n and i+n &lt;= size s.  
<p>

   A valid substring (s, i, n) represents the string s<code class="code">i...i+n-1</code>.  
<p>

   Invariant in the implementation: Any value of type <code class="code">Substring.t</code> is valid.<br>
<hr width="100%">
<pre><span class="keyword">type</span> <a name="TYPEt"></a><code class="type"></code>t </pre>
<div class="info">
<code class="code">Substring.t</code> is the type of substrings of a basestring, an efficient 
   representation of a piece of a string.
<p>

   A substring (s,i,n) is valid if 0 &lt;= i &lt;= i+n &lt;= size s, 
                  or equivalently, 0 &lt;= i and 0 &lt;= n and i+n &lt;= size s.  
<p>

   A valid substring (s, i, n) represents the string s<code class="code">i...i+n-1</code>.  
<p>

   Invariant in the implementation: Any value of type <code class="code">Substring.t</code> is valid.<br>
</div>

<pre><span class="keyword">val</span> <a name="VALempty"></a>empty : <code class="type">unit -> <a href="Substring.html#TYPEt">t</a></code></pre><pre><span class="keyword">val</span> <a name="VALto_string"></a>to_string : <code class="type"><a href="Substring.html#TYPEt">t</a> -> string</code></pre><div class="info">
<code class="code">string sus</code> is the string s<code class="code">i..i+n-1</code> represented by sus = (s, i, n).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALof_string"></a>of_string : <code class="type">string -> <a href="Substring.html#TYPEt">t</a></code></pre><pre><span class="keyword">val</span> <a name="VALmake"></a>make : <code class="type">int -> char -> <a href="Substring.html#TYPEt">t</a></code></pre><pre><span class="keyword">val</span> <a name="VALcreate"></a>create : <code class="type">int -> <a href="Substring.html#TYPEt">t</a></code></pre><pre><span class="keyword">val</span> <a name="VALof_input"></a>of_input : <code class="type"><a href="IO.html#TYPEinput">IO.input</a> -> <a href="Substring.html#TYPEt">t</a></code></pre><pre><span class="keyword">val</span> <a name="VALsubstring"></a>substring : <code class="type">string -> int -> int -> <a href="Substring.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">substring s o l</code> returns a substring with base-string <code class="code">s</code>, offset
      <code class="code">o</code> and length <code class="code">l</code>.  Arguments are checked for validity
<p>

      <code class="code">substring(s, i, n)</code> creates the substring (s, i, n), consisting
      of the substring of s with length n starting at i.  Raises
      Inavlid_argument if i&lt;0 or n&lt;0 or i+n &gt; size s.  Equivalent to
      extract(s, i, SOME n).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALextract"></a>extract : <code class="type">string -> int -> int option -> <a href="Substring.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">extract(s, i, NONE)</code> creates the substring (s, i, size s-i)
      consisting of the tail of s starting at i.  Raises
      Invalid_argument if i&lt;0 or i &gt; size s.
<p>

      <code class="code">extract(s, i, SOME n)</code> creates the substring (s, i, n), consisting
      of the substring of s with length n starting at i.  Raises
      Invalid_argument if i&lt;0 or n&lt;0 or i+n &gt; size s.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALall"></a>all : <code class="type">string -> <a href="Substring.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">all s</code> is the substring (s, 0, size s).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbase"></a>base : <code class="type"><a href="Substring.html#TYPEt">t</a> -> string * int * int</code></pre><div class="info">
<code class="code">base sus</code> is the concrete triple (s, i, n), where sus = (s, i,
      n).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALis_empty"></a>is_empty : <code class="type"><a href="Substring.html#TYPEt">t</a> -> bool</code></pre><div class="info">
<code class="code">isEmpty (s, i, n)</code> true if the substring is empty (that is, n =
      0).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALgetc"></a>getc : <code class="type"><a href="Substring.html#TYPEt">t</a> -> (char * <a href="Substring.html#TYPEt">t</a>) option</code></pre><div class="info">
<code class="code">getc sus</code> returns SOME(c, rst) where c is the first character and
      rst the remainder of sus, if sus is non-empty; otherwise returns
      NONE.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfirst"></a>first : <code class="type"><a href="Substring.html#TYPEt">t</a> -> char option</code></pre><div class="info">
<code class="code">first sus</code> returns SOME c where c is the first character in
      sus, if sus is non-empty; otherwise returns NONE.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtriml"></a>triml : <code class="type">int -> <a href="Substring.html#TYPEt">t</a> -> <a href="Substring.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">triml k sus</code> returns sus less its leftmost k characters; or the
      empty string at the end of sus if it has less than k characters.
       if k &lt; 0, even in the partial application
      triml(k).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtrimr"></a>trimr : <code class="type">int -> <a href="Substring.html#TYPEt">t</a> -> <a href="Substring.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">trimr k sus</code> returns sus less its rightmost k characters; or the
      empty string at the beginning of sus if it has less than k
      characters.  Raises Invalid_argument if k &lt; 0, even in the partial
      application triml(k).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget"></a>get : <code class="type">int -> <a href="Substring.html#TYPEt">t</a> -> char</code></pre><div class="info">
<code class="code">sub (sus, k)</code> returns the k'th character of the substring; that
      is, s(i+k) where sus = (s, i, n).  Raises Invalid_argument if
      k&lt;0 or k&gt;=n.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsize"></a>size : <code class="type"><a href="Substring.html#TYPEt">t</a> -> int</code></pre><div class="info">
<code class="code">size (s, i, n)</code> returns the size of the substring, that is, n.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALslice"></a>slice : <code class="type"><a href="Substring.html#TYPEt">t</a> -> int -> int option -> <a href="Substring.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">slice (sus, i', NONE)</code> returns the substring (s, i+i', n-i'),
      where sus = (s, i, n).  Raises Invalid_argument if i' &lt; 0 or i' &gt; n.  
<p>

      <code class="code">slice (sus, i', SOME n')</code> returns the substring (s, i+i', n'),
      where sus = (s, i, n).  Raises Invalid_argument if i' &lt; 0 or n' &lt; 0 or
      i'+n' &gt;= n.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconcat"></a>concat : <code class="type"><a href="Substring.html#TYPEt">t</a> list -> string</code></pre><div class="info">
<code class="code">concat suss</code> returns a string consisting of the concatenation of
      the substrings.  Equivalent to String.concat (List.map string
      suss).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALexplode"></a>explode : <code class="type"><a href="Substring.html#TYPEt">t</a> -> char list</code></pre><div class="info">
<code class="code">explode sus</code> returns the list of characters of sus, that is,
      <code class="code">s(i), s(i+1), ..., s(i+n-1)</code> where sus = (s, i, n).  Equivalent
      to String.explode(string ss).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALis_prefix"></a>is_prefix : <code class="type">string -> <a href="Substring.html#TYPEt">t</a> -> bool</code></pre><div class="info">
<code class="code">isPrefix s1 s2</code> is true if s1 is a prefix of s2. That is, if
      there exists a string t such that string s1 ^ t = string s2.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcompare"></a>compare : <code class="type"><a href="Substring.html#TYPEt">t</a> -> <a href="Substring.html#TYPEt">t</a> -> int</code></pre><div class="info">
<code class="code">compare (sus1, sus2)</code> performs lexicographic comparison, using
      the standard ordering Char.compare on the characters.  Returns
      LESS, EQUAL, or GREATER, according as sus1 is less than, equal
      to, or greater than sus2.  Equivalent to, but more efficient
      than, String.compare(string sus1, string sus2).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdropl"></a>dropl : <code class="type">(char -> bool) -> <a href="Substring.html#TYPEt">t</a> -> <a href="Substring.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">dropl p sus</code> drops the longest prefix (left substring) of sus
      all of whose characters satisfy predicate p.  If all characters
      do, it returns the empty substring (s, i+n, 0) where sus = (s,
      i, n).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdropr"></a>dropr : <code class="type">(char -> bool) -> <a href="Substring.html#TYPEt">t</a> -> <a href="Substring.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">dropr p sus</code> drops the longest suffix (right substring) of sus all
   of whose characters satisfy predicate p.  If all characters do, it
   returns the empty substring (s, i, 0) where sus = (s, i, n).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtakel"></a>takel : <code class="type">(char -> bool) -> <a href="Substring.html#TYPEt">t</a> -> <a href="Substring.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">takel p sus</code> returns the longest prefix (left substring) of sus
   all of whose characters satisfy predicate p.  That is, if the
   left-most character does not satisfy p, returns the empty (s, i, 0)
   where sus = (s, i, n).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtaker"></a>taker : <code class="type">(char -> bool) -> <a href="Substring.html#TYPEt">t</a> -> <a href="Substring.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">taker p sus</code> returns the longest suffix (right substring) of sus
   all of whose characters satisfy predicate p.  That is, if the
   right-most character satisfies p, returns the empty (s, i+n, 0)
   where sus = (s, i, n).
<p>

   Let p be a predicate and xxxxfyyyyfzzzz a string where all
   characters in xxxx and zzzz satisfy p, and f a is character
   not satisfying p.  Then
<p>

   sus = xxxxfyyyyfzzzz         sus = xxxxzzzz
   ------------------------------------------------------
   dropl p sus =     fyyyyfzzzz               
   dropr p sus = xxxxfyyyyf       
   takel p sus = xxxx                         xxxxzzzz
   taker p sus =           zzzz               xxxxzzzz
<p>

   It also holds that 
   concat<code class="code">takel p sus, dropl p sus</code> = string sus
   concat<code class="code">dropr p sus, taker p sus</code> = string sus<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsplitl"></a>splitl : <code class="type">(char -> bool) -> <a href="Substring.html#TYPEt">t</a> -> <a href="Substring.html#TYPEt">t</a> * <a href="Substring.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">splitl p sus</code> splits sus into a pair (sus1, sus2) of substrings
   where sus1 is the longest prefix (left substring) all of whose
   characters satisfy p, and sus2 is the rest.  That is, sus2 begins
   with the leftmost character not satisfying p.  Disregarding
   sideeffects, we have: 
   splitl p sus = (takel p sus, dropl p sus).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsplitr"></a>splitr : <code class="type">(char -> bool) -> <a href="Substring.html#TYPEt">t</a> -> <a href="Substring.html#TYPEt">t</a> * <a href="Substring.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">splitr p sus</code> splits sus into a pair (sus1, sus2) of substrings
   where sus2 is the longest suffix (right substring) all of whose
   characters satisfy p, and sus1 is the rest.  That is, sus1 ends
   with the rightmost character not satisfying p.  Disregarding
   sideeffects, we have:
   splitr p sus = (dropr p sus, taker p sus)<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsplit_at"></a>split_at : <code class="type">int -> <a href="Substring.html#TYPEt">t</a> -> <a href="Substring.html#TYPEt">t</a> * <a href="Substring.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">splitAt (sus, k)</code> returns the pair (sus1, sus2) of substrings,
   where sus1 contains the first k characters of sus, and sus2
   contains the rest.  Raises Invalid_argument if k &lt; 0 or k &gt; size sus.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALspan"></a>span : <code class="type"><a href="Substring.html#TYPEt">t</a> -> <a href="Substring.html#TYPEt">t</a> -> <a href="Substring.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">span (sus1, sus2)</code> returns a substring spanning from the start of
   sus1 to the end of sus2, provided this is well-defined: sus1 and
   sus2 must have the same underlying string, and the start of sus1
   must not be to the right of the end of sus2; otherwise raises Span.
<p>

   More precisely, if base(sus1) = (s,i,n) and base(sus2) = (s',i',n') 
   and s = s' and i &lt;= i'+n', then base(join(sus1, sus2)) = (s, i, i'+n'-i).
   This may be used to compute `span', `union', and `intersection'.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtranslate"></a>translate : <code class="type">(char -> char) -> <a href="Substring.html#TYPEt">t</a> -> string</code></pre><div class="info">
<code class="code">translate f sus</code> applies f to every character of sus, from left to
   right, and returns the concatenation of the results.  Raises Size
   if the sum of their sizes is greater than String.maxSize.
   Equivalent to String.concat(List.map f (explode sus)).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtokens"></a>tokens : <code class="type">(char -> bool) -> <a href="Substring.html#TYPEt">t</a> -> <a href="Substring.html#TYPEt">t</a> list</code></pre><div class="info">
<code class="code">tokens p sus</code> returns the list of tokens in sus, from left to right, 
   where a token is a non-empty maximal substring of sus not containing 
   any delimiter, and a delimiter is a character satisfying p.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfields"></a>fields : <code class="type">(char -> bool) -> <a href="Substring.html#TYPEt">t</a> -> <a href="Substring.html#TYPEt">t</a> list</code></pre><div class="info">
<code class="code">fields p sus</code> returns the list of fields in sus, from left to right, 
   where a field is a (possibly empty) maximal substring of sus not 
   containing any delimiter, and a delimiter is a character satisfying p.
<p>

   Two tokens may be separated by more than one delimiter, whereas two
   fields are separated by exactly one delimiter.  If the only delimiter 
   is the character #"|", then
   "abc||def" contains two tokens:   "abc" and "def"
   "abc||def" contains three fields: "abc" and "" and "def"<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold_left"></a>fold_left : <code class="type">('a -> char -> 'a) -> 'a -> <a href="Substring.html#TYPEt">t</a> -> 'a</code></pre><div class="info">
<code class="code">foldl f e sus</code> folds f over sus from left to right.  That is,
      evaluates f(s<code class="code">i+n-1</code>, f( ... f(s<code class="code">i+1</code>, f(s<code class="code">i</code> % e)) ...))
      tail-recursively, where sus = (s, i, n).  Equivalent to List.foldl
      f e (explode sus).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold_right"></a>fold_right : <code class="type">(char -> 'a -> 'a) -> <a href="Substring.html#TYPEt">t</a> -> 'a -> 'a</code></pre><div class="info">
<code class="code">foldr f e sus</code> folds f over sus from right to left.  That is,
      evaluates f(s<code class="code">i</code>, f(s<code class="code">i+1</code>, f(... f(s<code class="code">i+n-1</code> % e) ...)))
      tail-recursively, where sus = (s, i, n).  Equivalent to List.foldr
      f e (explode sus).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALiter"></a>iter : <code class="type">(char -> unit) -> <a href="Substring.html#TYPEt">t</a> -> unit</code></pre><div class="info">
<code class="code">iter f sus</code> applies f to all characters of sus, from left to
      right.  Equivalent to List.app f (explode sus).<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtrim"></a>trim : <code class="type"><a href="Substring.html#TYPEt">t</a> -> <a href="Substring.html#TYPEt">t</a></code></pre><div class="info">
removes whitespace from left and right ends of input<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsplit_on_char"></a>split_on_char : <code class="type">char -> <a href="Substring.html#TYPEt">t</a> -> <a href="Substring.html#TYPEt">t</a> list</code></pre><div class="info">
<code class="code">split_on_char c ss</code> returns substrings of input <code class="code">ss</code> as divided
  by <code class="code">c</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALsplit_on_pipe"></a>split_on_pipe : <code class="type"><a href="Substring.html#TYPEt">t</a> -> <a href="Substring.html#TYPEt">t</a> list</code></pre><pre><span class="keyword">val</span> <a name="VALsplit_on_dot"></a>split_on_dot : <code class="type"><a href="Substring.html#TYPEt">t</a> -> <a href="Substring.html#TYPEt">t</a> list</code></pre><pre><span class="keyword">val</span> <a name="VALsplit_on_comma"></a>split_on_comma : <code class="type"><a href="Substring.html#TYPEt">t</a> -> <a href="Substring.html#TYPEt">t</a> list</code></pre><pre><span class="keyword">val</span> <a name="VALsplit_on_slash"></a>split_on_slash : <code class="type"><a href="Substring.html#TYPEt">t</a> -> <a href="Substring.html#TYPEt">t</a> list</code></pre></body></html>