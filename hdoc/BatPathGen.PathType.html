<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="BatPathGen.StringType.html">
<link rel="Up" href="BatPathGen.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="BatArg" rel="Chapter" href="BatArg.html">
<link title="BatArray" rel="Chapter" href="BatArray.html">
<link title="BatAvlTree" rel="Chapter" href="BatAvlTree.html">
<link title="BatBase64" rel="Chapter" href="BatBase64.html">
<link title="BatBig_int" rel="Chapter" href="BatBig_int.html">
<link title="BatBigarray" rel="Chapter" href="BatBigarray.html">
<link title="BatBitSet" rel="Chapter" href="BatBitSet.html">
<link title="BatBool" rel="Chapter" href="BatBool.html">
<link title="BatBuffer" rel="Chapter" href="BatBuffer.html">
<link title="BatCamomile" rel="Chapter" href="BatCamomile.html">
<link title="BatChar" rel="Chapter" href="BatChar.html">
<link title="BatCharEncodings" rel="Chapter" href="BatCharEncodings.html">
<link title="BatCharParser" rel="Chapter" href="BatCharParser.html">
<link title="BatComplex" rel="Chapter" href="BatComplex.html">
<link title="BatConcurrent" rel="Chapter" href="BatConcurrent.html">
<link title="BatDeque" rel="Chapter" href="BatDeque.html">
<link title="BatDigest" rel="Chapter" href="BatDigest.html">
<link title="BatDllist" rel="Chapter" href="BatDllist.html">
<link title="BatDynArray" rel="Chapter" href="BatDynArray.html">
<link title="BatEnum" rel="Chapter" href="BatEnum.html">
<link title="BatFile" rel="Chapter" href="BatFile.html">
<link title="BatFloat" rel="Chapter" href="BatFloat.html">
<link title="BatFormat" rel="Chapter" href="BatFormat.html">
<link title="BatGc" rel="Chapter" href="BatGc.html">
<link title="BatGenlex" rel="Chapter" href="BatGenlex.html">
<link title="BatGlobal" rel="Chapter" href="BatGlobal.html">
<link title="BatHashcons" rel="Chapter" href="BatHashcons.html">
<link title="BatHashtbl" rel="Chapter" href="BatHashtbl.html">
<link title="BatHeap" rel="Chapter" href="BatHeap.html">
<link title="BatIMap" rel="Chapter" href="BatIMap.html">
<link title="BatIO" rel="Chapter" href="BatIO.html">
<link title="BatISet" rel="Chapter" href="BatISet.html">
<link title="BatInnerIO" rel="Chapter" href="BatInnerIO.html">
<link title="BatInnerWeaktbl" rel="Chapter" href="BatInnerWeaktbl.html">
<link title="BatInt" rel="Chapter" href="BatInt.html">
<link title="BatInt32" rel="Chapter" href="BatInt32.html">
<link title="BatInt64" rel="Chapter" href="BatInt64.html">
<link title="BatInterfaces" rel="Chapter" href="BatInterfaces.html">
<link title="BatLazyList" rel="Chapter" href="BatLazyList.html">
<link title="BatLexing" rel="Chapter" href="BatLexing.html">
<link title="BatList" rel="Chapter" href="BatList.html">
<link title="BatLogger" rel="Chapter" href="BatLogger.html">
<link title="BatMap" rel="Chapter" href="BatMap.html">
<link title="BatMarshal" rel="Chapter" href="BatMarshal.html">
<link title="BatMonad" rel="Chapter" href="BatMonad.html">
<link title="BatMultiPMap" rel="Chapter" href="BatMultiPMap.html">
<link title="BatMutex" rel="Chapter" href="BatMutex.html">
<link title="BatNativeint" rel="Chapter" href="BatNativeint.html">
<link title="BatNum" rel="Chapter" href="BatNum.html">
<link title="BatNumber" rel="Chapter" href="BatNumber.html">
<link title="BatOo" rel="Chapter" href="BatOo.html">
<link title="BatOptParse" rel="Chapter" href="BatOptParse.html">
<link title="BatOption" rel="Chapter" href="BatOption.html">
<link title="BatPMap" rel="Chapter" href="BatPMap.html">
<link title="BatPSet" rel="Chapter" href="BatPSet.html">
<link title="BatPair" rel="Chapter" href="BatPair.html">
<link title="BatParserCo" rel="Chapter" href="BatParserCo.html">
<link title="BatPathGen" rel="Chapter" href="BatPathGen.html">
<link title="BatPervasives" rel="Chapter" href="BatPervasives.html">
<link title="BatPrint" rel="Chapter" href="BatPrint.html">
<link title="BatPrintexc" rel="Chapter" href="BatPrintexc.html">
<link title="BatPrintf" rel="Chapter" href="BatPrintf.html">
<link title="BatQueue" rel="Chapter" href="BatQueue.html">
<link title="BatRMutex" rel="Chapter" href="BatRMutex.html">
<link title="BatRandom" rel="Chapter" href="BatRandom.html">
<link title="BatRef" rel="Chapter" href="BatRef.html">
<link title="BatRefList" rel="Chapter" href="BatRefList.html">
<link title="BatResult" rel="Chapter" href="BatResult.html">
<link title="BatReturn" rel="Chapter" href="BatReturn.html">
<link title="BatRope" rel="Chapter" href="BatRope.html">
<link title="BatScanf" rel="Chapter" href="BatScanf.html">
<link title="BatSeq" rel="Chapter" href="BatSeq.html">
<link title="BatSet" rel="Chapter" href="BatSet.html">
<link title="BatStack" rel="Chapter" href="BatStack.html">
<link title="BatStd" rel="Chapter" href="BatStd.html">
<link title="BatStr" rel="Chapter" href="BatStr.html">
<link title="BatStream" rel="Chapter" href="BatStream.html">
<link title="BatString" rel="Chapter" href="BatString.html">
<link title="BatSubstring" rel="Chapter" href="BatSubstring.html">
<link title="BatSys" rel="Chapter" href="BatSys.html">
<link title="BatUChar" rel="Chapter" href="BatUChar.html">
<link title="BatUCharParser" rel="Chapter" href="BatUCharParser.html">
<link title="BatUTF8" rel="Chapter" href="BatUTF8.html">
<link title="BatUnit" rel="Chapter" href="BatUnit.html">
<link title="BatUnix" rel="Chapter" href="BatUnix.html">
<link title="BatUref" rel="Chapter" href="BatUref.html">
<link title="BatValue_printer" rel="Chapter" href="BatValue_printer.html">
<link title="BatVect" rel="Chapter" href="BatVect.html">
<link title="Batteries" rel="Chapter" href="Batteries.html">
<link title="Batteries_config" rel="Chapter" href="Batteries_config.html">
<link title="Batteries_print" rel="Chapter" href="Batteries_print.html">
<link title="Batteries_uni" rel="Chapter" href="Batteries_uni.html"><link title="Construction" rel="Section" href="#6_Construction">
<link title="Validation" rel="Section" href="#6_Validation">
<link title="Conversions" rel="Section" href="#6_Conversions">
<link title="Name related functions" rel="Section" href="#6_Namerelatedfunctions">
<link title="Supplementary functions" rel="Section" href="#6_Supplementaryfunctions">
<link title="Convenience aliases" rel="Subsection" href="#7_Conveniencealiases">
<title>BatPathGen.PathType</title>
</head>
<body>
<div class="navbar"><a href="BatPathGen.StringType.html">Previous</a>
&nbsp;<a href="BatPathGen.html">Up</a>
&nbsp;</div>
<center><h1>Module type <a href="type_BatPathGen.PathType.html">BatPathGen.PathType</a></h1></center>
<br>
<pre><span class="keyword">module type</span> PathType = <code class="code">sig</code> <a href="BatPathGen.PathType.html">..</a> <code class="code">end</code></pre>All implementations of <code class="code">Path</code> functionality have this module type.<br>
<hr width="100%">
<pre><span class="keyword">type</span> <a name="TYPEustring"></a><code class="type"></code>ustring </pre>
<div class="info">
Type of strings used. In case of <code class="code">Path.OfRope</code> it is <code class="code">Rope.t</code> and in <code class="code">Path.OfString</code> module it is  <code class="code">string</code>.<br>
</div>

<pre><span class="keyword">type</span> <a name="TYPEuchar"></a><code class="type"></code>uchar </pre>
<div class="info">
Type of characters. It corresponds to <code class="code">ustring</code> type.<br>
</div>

<pre><span class="keyword">module</span> <a href="BatPathGen.PathType.OperatorLift.html">OperatorLift</a>: <code class="code">sig</code> <a href="BatPathGen.PathType.OperatorLift.html">..</a> <code class="code">end</code></pre><div class="info">
Convenience operator for lifting primitive strings to <code class="code">ustring</code> type.
</div>
<pre><span class="keyword">type</span> <a name="TYPEt"></a><code class="type"></code>t = <code class="type"><a href="BatPathGen.PathType.html#TYPEustring">ustring</a> list</code> </pre>
<div class="info">
A type for storing paths. It is reversed list of names. In case of absolute path, the last element of the list is empty string (<em>Windows:</em> empty or letter-colon; details below). Empty list represents empty relative path.
<p>

  Examples: <code class="code">["a";"b";"c"]</code> is c/b/a (relative path); <code class="code">["d";"e";""]</code> stays for /e/d (absolute path).
<p>

  All examples here and below are given for <code class="code">ustring</code>=<code class="code">string</code> case for clarity. To have the code working with other string types, one should prepend the <code class="code">!!</code> operator (<a href="BatPathGen.PathType.OperatorLift.html#VAL(!!)"><code class="code">BatPathGen.PathType.OperatorLift.(!!)</code></a>) to all string literals.
<p>

  There are two infix operators provided to allow to write expressions in natural order. For example, to build a path using <a href="BatPathGen.PathType.Operators.html#VAL(/:)"><code class="code">BatPathGen.PathType.Operators.(/:)</code></a> one can write:
<p>

  <code class="code">base_dir/:"bar"</code> instead of <code class="code">"bar"::base_dir</code>
<p>

  However it may be sometimes inevitable to write components in reverse, for example:
<p>

  <code class="code">let whose_readme = function "README"::app::"doc"::"share"::_ -&gt; Some app | _ -&gt; None</code>
<p>

<em>Windows:</em> Windows absolute paths start with "\\" or with drive letter. Use following representation:<ul>
<li><code class="code">Path.root/:"."/:"pipe" = ["pipe";".";""]</code>  for "\\.\pipe"</li>
<li><code class="code">["C:"]/:"foo" = ["foo";"C:"]</code> for "C:\foo"</li>
</ul>

 In principle the first type of paths has broader range of allowed characters, but this implementation applies more strict rules to both (<a href="BatPathGen.PathType.html#VALdefault_validator"><code class="code">BatPathGen.PathType.default_validator</code></a>).<br>
</div>

<pre><span class="keyword">val</span> <a name="VALis_relative"></a>is_relative : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> -> bool</code></pre><pre><span class="keyword">val</span> <a name="VALis_absolute"></a>is_absolute : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> -> bool</code></pre><br>
<a name="6_Construction"></a>
<h6>Construction</h6><br>
<pre><span class="keyword">val</span> <a name="VALroot"></a>root : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a></code></pre><div class="info">
Root of the filesystem (<code class="code">[""]</code>). It is minimal absolute path. Below it is called 'empty'. However it yields "/" or "\\" when converted to a string.
<p>

<em>Windows:</em> This path (root and nothing more) is meaningless, but for simplicity it is considered valid here. To create absolute path starting with drive letter, construct the list explicitly (as in <code class="code">["C:"]/:"foo"</code>).
A path consisting of drive letter only is also called 'empty' here.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALappend"></a>append : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEustring">ustring</a> -> <a href="BatPathGen.PathType.html#TYPEt">t</a></code></pre><div class="info">
Alternative name for <a href="BatPathGen.PathType.Operators.html#VAL(/:)"><code class="code">BatPathGen.PathType.Operators.(/:)</code></a><br>
</div>
<pre><span class="keyword">val</span> <a name="VALconcat"></a>concat : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEt">t</a></code></pre><div class="info">
Alternative name for <a href="BatPathGen.PathType.Operators.html#VAL(//@)"><code class="code">BatPathGen.PathType.Operators.(//@)</code></a><br>
</div>
<pre><span class="keyword">module</span> <a href="BatPathGen.PathType.Operators.html">Operators</a>: <code class="code">sig</code> <a href="BatPathGen.PathType.Operators.html">..</a> <code class="code">end</code></pre><div class="info">
Infix operators for path construction.
</div>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONMalformed_path"></a>Malformed_path</pre>
<pre><span class="keyword">val</span> <a name="VALnormalize_filepath"></a>normalize_filepath : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEt">t</a></code></pre><div class="info">
Consumes single dots where possible, e.g.:
<p>

  <code class="code">normalize ([".."]/:"foo"/:"."/:"bar"/:"sub1"/:".."/:"sub2") = [".."]/:"foo"/:"bar"/:"sub1"/:".."/:"sub2"</code>
<p>

  When a directory structure contains links, it can be not pefectly pure tree. Then meaing of the ".." symbol depends on the real nature of parent of what is denoted by the name that preceded the ".." symbol. This symbol cannot be resolved for a graph traversal case when dealing with abstract paths only.
<p>

<em>Windows:</em> If single dot is next to root, it is preserved.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALnormalize_in_graph"></a>normalize_in_graph : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEt">t</a></code></pre><div class="info">
Another name for <code class="code">normalize_filepath</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALnormalize_in_tree"></a>normalize_in_tree : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEt">t</a></code></pre><div class="info">
Consumes single dots and applies double dots where possible, e.g.:
<p>

  <code class="code">normalize ([".."]/:"foo"/:"."/:"bar"/:"sub1"/:".."/:"sub2") = [".."]/:"foo"/:"bar"/:"sub2"</code>
<p>

  This normalization is useful when dealing with paths that describe locations in a tree and the ".." symbol always points to the only parent of what precedes this symbol.
<p>

<em>Windows:</em> If single dot is next to root, it is preserved.<br>
<b>Raises</b> <code>Malformed_path</code> when absolute path is given that contains double dots that would be applied to the root.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALnormalize"></a>normalize : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEt">t</a></code></pre><div class="info">
Deprecated name for <code class="code">normalize_in_tree</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALparent"></a>parent : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEt">t</a></code></pre><div class="info">
Returns parent path, i.e. immediate ancestor: <code class="code">parent (foo/:bar) = foo</code><br>
<b>Raises</b> <code>Invalid_argument</code> if empty path (relative <code class="code">[]</code> or absolute <code class="code">[""]</code>) is given<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbelongs"></a>belongs : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEt">t</a> -> bool</code></pre><div class="info">
<code class="code">belongs base sub</code> is <code class="code">true</code> when <code class="code">sub</code> descends from <code class="code">base</code>, i.e. <code class="code">base</code> is a prefix of <code class="code">sub</code>. If <code class="code">base</code>=<code class="code">sub</code> the function returns <code class="code">true</code>. It is otherwise <code class="code">false</code>.
Both arguments must be absolute paths or both relative.
<p>

If both arguments have a root portion with drive letter and these letters are different, <code class="code">belongs base sub</code> returns false.<br>
<b>Raises</b> <code>Invalid_argument</code> if exactly one of given arguments is absolute path<br>
</div>
<pre><span class="keyword">val</span> <a name="VALrelative_to_any"></a>relative_to_any : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">relative_to_any base sub</code> returns relative path <code class="code">rel</code> such that
<code class="code">normalize (base/:rel) = normalize sub</code>, i.e. common base is stripped and ".." are added if necessary.
Both arguments must be absolute paths or both relative.
<p>

This function normalizes <code class="code">base</code> and <code class="code">sub</code> before calculation of the relative path.
<p>

<em>Windows:</em> If <code class="code">base</code> and <code class="code">sub</code> are absolute, they must have the same root element: have the same drive letter or both starting with <a href="BatPathGen.PathType.html#VALroot"><code class="code">BatPathGen.PathType.root</code></a> (i.e. <code class="code">""</code> is the last element of the list).
Exceptionally it is possible to get an absolute path as a result if drive letter is in <code class="code">sub</code> but not as a root element (e .g. <code class="code">base = root/:"bar"</code> and <code class="code">sub = root/:bar//@(["C:"]/:"foo"</code>).<br>
<b>Raises</b><ul><li><code>Invalid_argument</code> if exactly one of given arguments is an absolute path</li>
<li><code>Malformed_path</code> if normalization fails (see <a href="BatPathGen.PathType.html#VALnormalize"><code class="code">BatPathGen.PathType.normalize</code></a>)</li>
</ul>
<b>See also</b> <code class="code">relative_to_parent</code> may be sometimes more suitable<br>
</div>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONNot_parent"></a>Not_parent</pre>
<pre><span class="keyword">val</span> <a name="VALrelative_to_parent"></a>relative_to_parent : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">relative_to_parent parent sub</code> returns relative path <code class="code">rel</code> such that
<code class="code">(normalize parent)/:rel = normalize sub</code>. It is checked if <code class="code">sub</code> is really a descendant of <code class="code">parent</code>.
Both arguments must be absolute paths or both relative.
<p>

This function normalizes <code class="code">base</code> and <code class="code">sub</code> before calculation of the relative path.
<p>

<em>Windows:</em> Exceptionally it is possible to get an absolute path as a result if drive letter is in <code class="code">sub</code> but not as a root element (e .g. <code class="code">base = root/:"bar"</code> and <code class="code">sub = root/:bar//@(["C:"]/:"foo")</code>).<br>
<b>Raises</b><ul><li><code>Not_parent</code> if <code class="code">sub</code> is not descendant of <code class="code">parent</code></li>
<li><code>Invalid_argument</code> if exactly one of given arguments is absolute path</li>
<li><code>Malformed_path</code> if normalization fails (see <a href="BatPathGen.PathType.html#VALnormalize"><code class="code">BatPathGen.PathType.normalize</code></a>)</li>
</ul>
</div>
<br>
<a name="6_Validation"></a>
<h6>Validation</h6><br>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONIllegal_char"></a>Illegal_char</pre>
<div class="info">
Raised by <a href="BatPathGen.PathType.html#VALof_string"><code class="code">BatPathGen.PathType.of_string</code></a>, <a href="BatPathGen.PathType.html#VALappend"><code class="code">BatPathGen.PathType.append</code></a> and <a href="BatPathGen.PathType.Operators.html#VAL(/:)"><code class="code">BatPathGen.PathType.Operators.(/:)</code></a> when used validator finds illegal character.<br>
</div>
<pre><span class="keyword">type</span> <a name="TYPEvalidator"></a><code class="type"></code>validator = <code class="type"><a href="BatPathGen.PathType.html#TYPEustring">ustring</a> -> bool</code> </pre>
<div class="info">
Validators should check if all characters of given string can be used in a name (path component). Return true if the name is valid. Return false if illegal character is found.
<p>

If a name should be rejected for some other reason, user defined validator may raise an exception.<br>
</div>

<pre><span class="keyword">val</span> <a name="VALdefault_validator"></a>default_validator : <code class="type"><a href="BatPathGen.PathType.html#TYPEvalidator">validator</a> Pervasives.ref</code></pre><div class="info">
Forward slash and code zero are considered invalid.
<p>

<em>Windows:</em> Invalid characters are *?:\/&lt;&gt; and all with code &lt;32. Exception: the function <a href="BatPathGen.PathType.html#VALof_string"><code class="code">BatPathGen.PathType.of_string</code></a> doesn't use validator against drive letter with colon.<br>
</div>
<br>
<a name="6_Conversions"></a>
<h6>Conversions</h6><br>
<pre><span class="keyword">val</span> <a name="VALto_ustring"></a>to_ustring : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEustring">ustring</a></code></pre><div class="info">
Convert to the chosen <code class="code">ustring</code> type. Empty relative path is converted to "." (single dot).
<p>

 <em>Windows:</em> backslash is used as a separator and double backslash for root. If the path is only a drive letter (empty absolute path) trailing backslash is added (e.g. <code class="code">to_string ["C:"] = "C:\"</code>).<br>
<b>See also</b> <code class="code">to_string</code> is likely to bo more useful
 "<br>
</div>
<pre><span class="keyword">val</span> <a name="VALto_string"></a>to_string : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> -> string</code></pre><div class="info">
Convert to type primitive string with UTF-8 content. The string is built in the same way as by <code class="code">to_ustring</code> function.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALof_string"></a>of_string : <code class="type"><a href="BatPathGen.PathType.html#TYPEustring">ustring</a> -> <a href="BatPathGen.PathType.html#TYPEt">t</a></code></pre><div class="info">
Parse path in a given string. Any number of consecutive separators collapse ("a//b" becomes "a/b"). <code class="code">Path.default_validator</code> is applied to each resulting name.
<p>

<em>Windows:</em> both slashes '\' and '/' are accepted as separators. Paths of the 'semi-relative' form "C:foo\bar" are not recognized. For example "C:" string is parsed as <code class="code">["C:"]</code> which has different meaning (see <a href="BatPathGen.PathType.html#VALto_string"><code class="code">BatPathGen.PathType.to_string</code></a>).<br>
<b>Raises</b> <code>Illegal_char</code> when a character not allowed in paths is found.<br>
</div>
<br>
<a name="7_Conveniencealiases"></a>
<div class="h7">Convenience aliases</div><br>
<pre><span class="keyword">val</span> <a name="VALs"></a>s : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> -> string</code></pre><div class="info">
= <a href="BatPathGen.PathType.html#VALto_string"><code class="code">BatPathGen.PathType.to_string</code></a><br>
</div>
<pre><span class="keyword">val</span> <a name="VALp"></a>p : <code class="type"><a href="BatPathGen.PathType.html#TYPEustring">ustring</a> -> <a href="BatPathGen.PathType.html#TYPEt">t</a></code></pre><div class="info">
= <a href="BatPathGen.PathType.html#VALof_string"><code class="code">BatPathGen.PathType.of_string</code></a><br>
</div>
<br>
<a name="6_Namerelatedfunctions"></a>
<h6>Name related functions</h6>
These funtions do not accept empty paths, i.e. <code class="code">[]</code>, <code class="code">[""]</code> or <code class="code">["C:"]</code>.<br>
<pre><span class="keyword">val</span> <a name="VALname"></a>name : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEustring">ustring</a></code></pre><div class="info">
Returns name of the object the pathname points to, i.e.
<code class="code">name (foo/:bar) = bar</code><br>
<b>Raises</b> <code>Invalid_argument</code> if empty path (relative <code class="code">[]</code> or absolute <code class="code">[""]</code>) is given<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmap_name"></a>map_name : <code class="type">(<a href="BatPathGen.PathType.html#TYPEustring">ustring</a> -> <a href="BatPathGen.PathType.html#TYPEustring">ustring</a>) -><br>       <a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">map_name fu path</code> returns <code class="code">path</code> with the name replaced by <code class="code">fu (</code><a href="BatPathGen.PathType.html#VALname"><code class="code">BatPathGen.PathType.name</code></a><code class="code"> path)</code>.
<p>

Example: <code class="code">map_name (fun nn -&gt; nn ^ ".backup") (["foo"]/:"bar") = ["foo"]/:"bar.backup"</code>
<p>

<a href="BatPathGen.PathType.html#VALdefault_validator"><code class="code">BatPathGen.PathType.default_validator</code></a> is applied to new name.<br>
<b>Raises</b> <code>Illegal_char</code> (raised by validator if any bad character is found)<br>
</div>
<pre><span class="keyword">val</span> <a name="VALext"></a>ext : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEustring">ustring</a> option</code></pre><div class="info">
Returns extension of the name of the object the pathname points to. Examples:
<p>

<code class="code">ext ["aa.bb"] = Some "bb"</code>
<p>

<code class="code">ext ["aa."] = Some ""</code>
<p>

<code class="code">ext ["aa"] = None</code>
<p>

<code class="code">ext [".hidden"] = Some "hidden"</code> <em>(!)</em>
<p>

Extension begins where the rightmost dot in the name is found. If the name ends with a dot, the extension is empty and <code class="code">Some ""</code> is returned. If there is no extension (no dot) the function returns <code class="code">None</code>.<br>
<b>Raises</b> <code>Invalid_argument</code> if empty path (relative <code class="code">[]</code> or absolute <code class="code">[""]</code>) is given<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmap_ext"></a>map_ext : <code class="type">(<a href="BatPathGen.PathType.html#TYPEustring">ustring</a> option -> <a href="BatPathGen.PathType.html#TYPEustring">ustring</a> option) -><br>       <a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">map_ext fu path</code> returns <code class="code">path</code> but with the name with extension given by <code class="code">fu (</code><a href="BatPathGen.PathType.html#VALext"><code class="code">BatPathGen.PathType.ext</code></a><code class="code"> path)</code>. If <code class="code">fu</code> returns <code class="code">Some _</code>, the original extension may be replaced (when <code class="code">Some ext</code> is passed to <code class="code">fu</code>) or new added (when <code class="code">fu</code> gets <code class="code">None</code>). In case <code class="code">fu</code> returns <code class="code">None</code>, the extension is removed (if exists).<br>
<b>Raises</b><ul><li><code>Illegal_char</code> (raised by validator if any bad character is found)</li>
<li><code>Invalid_argument</code> if empty path (relative <code class="code">[]</code> or absolute <code class="code">[""]</code>) is given</li>
</ul>
</div>
<pre><span class="keyword">val</span> <a name="VALname_core"></a>name_core : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEustring">ustring</a></code></pre><div class="info">
Returns part of the name to the left of rightmost dot. Returns empty string if the name starts with a dot.<br>
<b>Raises</b> <code>Invalid_argument</code> if empty path (relative <code class="code">[]</code> or absolute <code class="code">[""]</code>) is given<br>
</div>
<pre><span class="keyword">type</span> <a name="TYPEcomponents"></a><code class="type"></code>components = <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> * <a href="BatPathGen.PathType.html#TYPEustring">ustring</a> *<br>       <a href="BatPathGen.PathType.html#TYPEustring">ustring</a> option</code> </pre>
<div class="info">
A <code class="code">path</code> can be represented by the following triple:
  <code class="code">(Path.parent path, Path.name_core path, Path.ext path)</code><br>
</div>

<pre><span class="keyword">val</span> <a name="VALsplit"></a>split : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEcomponents">components</a></code></pre><div class="info">
Dissect the path to its components (parent path, core part of name and possibly an extension).
<p>

Resulting <code class="code">name_core</code> string can be empty. For example,
<code class="code">Path.split (Path.root/:"home"/:"user"/:".bashrc")</code> equals <code class="code">(Path.root/:"home"/:"user", "", Some "bashrc")</code>.<br>
<b>Raises</b> <code>Invalid_argument</code> if empty path (relative <code class="code">[]</code> or absolute <code class="code">[""]</code>) is given<br>
</div>
<pre><span class="keyword">val</span> <a name="VALjoin"></a>join : <code class="type"><a href="BatPathGen.PathType.html#TYPEcomponents">components</a> -> <a href="BatPathGen.PathType.html#TYPEt">t</a></code></pre><div class="info">
Create a path from given components.<br>
<b>Raises</b> <code>Illegal_char</code> (raised by validator on any bad character)<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmap"></a>map : <code class="type">(<a href="BatPathGen.PathType.html#TYPEcomponents">components</a> -> <a href="BatPathGen.PathType.html#TYPEcomponents">components</a>) -><br>       <a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEt">t</a></code></pre><div class="info">
Map a path through a function that operates on separate components.<br>
<b>Raises</b><ul><li><code>Illegal_char</code> (raised by validator on any bad character)</li>
<li><code>Invalid_argument</code> if empty path (relative <code class="code">[]</code> or absolute <code class="code">[""]</code>) is given</li>
</ul>
</div>
<br>
<a name="6_Supplementaryfunctions"></a>
<h6>Supplementary functions</h6><br>
<pre><span class="keyword">val</span> <a name="VALdrive_letter"></a>drive_letter : <code class="type"><a href="BatPathGen.PathType.html#TYPEt">t</a> -> <a href="BatPathGen.PathType.html#TYPEuchar">uchar</a> option</code></pre><div class="info">
Return drive letter of the given absolute path.
<p>

<em>Windows:</em> <code class="code">drive_letter abs</code> returns <code class="code">None</code> if <code class="code">abs</code> is simple absolute path (i.e. begins with a separator), otherwise the root element of <code class="code">abs</code> consists of a letter <code class="code">ch</code> with a colon - in this case <code class="code">Some ch</code> is returned.
<p>

<em>Other systems:</em> Returns <code class="code">None</code> on all absolute paths.<br>
<b>Raises</b> <code>Invald_argument</code> if relative path is given<br>
</div>
</body></html>