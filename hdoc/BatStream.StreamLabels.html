<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="Up" href="BatStream.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="BatArg" rel="Chapter" href="BatArg.html">
<link title="BatArray" rel="Chapter" href="BatArray.html">
<link title="BatAvlTree" rel="Chapter" href="BatAvlTree.html">
<link title="BatBase64" rel="Chapter" href="BatBase64.html">
<link title="BatBig_int" rel="Chapter" href="BatBig_int.html">
<link title="BatBigarray" rel="Chapter" href="BatBigarray.html">
<link title="BatBitSet" rel="Chapter" href="BatBitSet.html">
<link title="BatBool" rel="Chapter" href="BatBool.html">
<link title="BatBuffer" rel="Chapter" href="BatBuffer.html">
<link title="BatChar" rel="Chapter" href="BatChar.html">
<link title="BatCharEncodings" rel="Chapter" href="BatCharEncodings.html">
<link title="BatCharParser" rel="Chapter" href="BatCharParser.html">
<link title="BatComplex" rel="Chapter" href="BatComplex.html">
<link title="BatConcurrent" rel="Chapter" href="BatConcurrent.html">
<link title="BatDigest" rel="Chapter" href="BatDigest.html">
<link title="BatDllist" rel="Chapter" href="BatDllist.html">
<link title="BatDynArray" rel="Chapter" href="BatDynArray.html">
<link title="BatEnum" rel="Chapter" href="BatEnum.html">
<link title="BatFile" rel="Chapter" href="BatFile.html">
<link title="BatFloat" rel="Chapter" href="BatFloat.html">
<link title="BatFormat" rel="Chapter" href="BatFormat.html">
<link title="BatGc" rel="Chapter" href="BatGc.html">
<link title="BatGenlex" rel="Chapter" href="BatGenlex.html">
<link title="BatGlobal" rel="Chapter" href="BatGlobal.html">
<link title="BatHashtbl" rel="Chapter" href="BatHashtbl.html">
<link title="BatIMap" rel="Chapter" href="BatIMap.html">
<link title="BatIO" rel="Chapter" href="BatIO.html">
<link title="BatISet" rel="Chapter" href="BatISet.html">
<link title="BatInnerIO" rel="Chapter" href="BatInnerIO.html">
<link title="BatInnerWeaktbl" rel="Chapter" href="BatInnerWeaktbl.html">
<link title="BatInt" rel="Chapter" href="BatInt.html">
<link title="BatInt32" rel="Chapter" href="BatInt32.html">
<link title="BatInt64" rel="Chapter" href="BatInt64.html">
<link title="BatInterfaces" rel="Chapter" href="BatInterfaces.html">
<link title="BatLazyList" rel="Chapter" href="BatLazyList.html">
<link title="BatLexing" rel="Chapter" href="BatLexing.html">
<link title="BatList" rel="Chapter" href="BatList.html">
<link title="BatLogger" rel="Chapter" href="BatLogger.html">
<link title="BatMap" rel="Chapter" href="BatMap.html">
<link title="BatMarshal" rel="Chapter" href="BatMarshal.html">
<link title="BatMonad" rel="Chapter" href="BatMonad.html">
<link title="BatMultiPMap" rel="Chapter" href="BatMultiPMap.html">
<link title="BatMutex" rel="Chapter" href="BatMutex.html">
<link title="BatNativeint" rel="Chapter" href="BatNativeint.html">
<link title="BatNum" rel="Chapter" href="BatNum.html">
<link title="BatNumber" rel="Chapter" href="BatNumber.html">
<link title="BatOo" rel="Chapter" href="BatOo.html">
<link title="BatOptParse" rel="Chapter" href="BatOptParse.html">
<link title="BatOption" rel="Chapter" href="BatOption.html">
<link title="BatPMap" rel="Chapter" href="BatPMap.html">
<link title="BatPSet" rel="Chapter" href="BatPSet.html">
<link title="BatPair" rel="Chapter" href="BatPair.html">
<link title="BatParserCo" rel="Chapter" href="BatParserCo.html">
<link title="BatPathGen" rel="Chapter" href="BatPathGen.html">
<link title="BatPervasives" rel="Chapter" href="BatPervasives.html">
<link title="BatPrint" rel="Chapter" href="BatPrint.html">
<link title="BatPrintexc" rel="Chapter" href="BatPrintexc.html">
<link title="BatPrintf" rel="Chapter" href="BatPrintf.html">
<link title="BatQueue" rel="Chapter" href="BatQueue.html">
<link title="BatRMutex" rel="Chapter" href="BatRMutex.html">
<link title="BatRandom" rel="Chapter" href="BatRandom.html">
<link title="BatRef" rel="Chapter" href="BatRef.html">
<link title="BatRefList" rel="Chapter" href="BatRefList.html">
<link title="BatResult" rel="Chapter" href="BatResult.html">
<link title="BatReturn" rel="Chapter" href="BatReturn.html">
<link title="BatRope" rel="Chapter" href="BatRope.html">
<link title="BatScanf" rel="Chapter" href="BatScanf.html">
<link title="BatSeq" rel="Chapter" href="BatSeq.html">
<link title="BatSet" rel="Chapter" href="BatSet.html">
<link title="BatStack" rel="Chapter" href="BatStack.html">
<link title="BatStd" rel="Chapter" href="BatStd.html">
<link title="BatStr" rel="Chapter" href="BatStr.html">
<link title="BatStream" rel="Chapter" href="BatStream.html">
<link title="BatString" rel="Chapter" href="BatString.html">
<link title="BatSubstring" rel="Chapter" href="BatSubstring.html">
<link title="BatSys" rel="Chapter" href="BatSys.html">
<link title="BatUChar" rel="Chapter" href="BatUChar.html">
<link title="BatUCharParser" rel="Chapter" href="BatUCharParser.html">
<link title="BatUTF8" rel="Chapter" href="BatUTF8.html">
<link title="BatUnit" rel="Chapter" href="BatUnit.html">
<link title="BatUnix" rel="Chapter" href="BatUnix.html">
<link title="BatValue_printer" rel="Chapter" href="BatValue_printer.html">
<link title="BatVect" rel="Chapter" href="BatVect.html">
<link title="Batteries_config" rel="Chapter" href="Batteries_config.html">
<link title="Batteries_help" rel="Chapter" href="Batteries_help.html">
<link title="Batteries_print" rel="Chapter" href="Batteries_print.html"><link title="Stream iterators" rel="Section" href="#6_Streamiterators">
<link title="Computation over stream" rel="Section" href="#6_Computationoverstream">
<link title="Streams pair arithmetic" rel="Section" href="#6_Streamspairarithmetic">
<link title="Stream arithmetic" rel="Section" href="#6_Streamarithmetic">
<title>BatStream.StreamLabels</title>
</head>
<body>
<div class="navbar">&nbsp;<a href="BatStream.html">Up</a>
&nbsp;</div>
<center><h1>Module <a href="type_BatStream.StreamLabels.html">BatStream.StreamLabels</a></h1></center>
<br>
<pre><span class="keyword">module</span> StreamLabels: <code class="code">sig</code> <a href="BatStream.StreamLabels.html">..</a> <code class="code">end</code></pre><hr width="100%">
<br>
<b>Note</b> This module is provided essentially for backwards-compatibility.
   If you feel like using <code class="code">Stream.t</code>, please take a look at <code class="code">BatEnum</code>
   or <code class="code">LazyList</code> and <code class="code">GenParser</code>.<br>
<br>
<a name="6_Streamiterators"></a>
<h6>Stream iterators</h6><br>
<pre><span class="keyword">val</span> <a name="VALiter"></a>iter : <code class="type">f:('a -> unit) -> 'a Stream.t -> unit</code></pre><div class="info">
<code class="code">Stream.iter f s</code> scans the whole stream s, applying function <code class="code">f</code>
   in turn to each stream element encountered.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfoldl"></a>foldl : <code class="type">f:('a -> 'b -> 'a * bool option) -> init:'a -> 'b Stream.t -> 'a</code></pre><div class="info">
<code class="code">foldl f init stream</code> is a lazy fold_left. <code class="code">f accu elt</code> should return
      <code class="code">(new_accu, state)</code> where <code class="code">new_accu</code> is normal accumulation result, and
      <code class="code">state</code> is a flag representing whether the computation should continue
      and whether the last operation is valid: <code class="code">None</code> means continue, <code class="code">Some b</code>
      means stop where <code class="code">b = true</code> means the last addition is still valid and <code class="code">b
      = false</code> means the last addition is invalid and should be revert.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfoldr"></a>foldr : <code class="type">f:('a -> 'b lazy_t -> 'b) -> init:'b -> 'a Stream.t -> 'b</code></pre><div class="info">
<code class="code">foldr f init stream</code> is a lazy fold_right. Unlike the normal fold_right,
      the accumulation parameter of <code class="code">f elt accu</code> is lazy, hence it can decide
      not to force the evaluation of <code class="code">accu</code> if the current element <code class="code">elt</code> can
      determin the result by itself.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold"></a>fold : <code class="type">f:('a -> 'a -> 'a * bool option) -> init:'a Stream.t -> 'a</code></pre><div class="info">
<code class="code">fold</code> is <code class="code">foldl</code> without initialization value, where the first
      element of stream is taken as <code class="code">init</code>. It raises <code class="code">End_of_stream</code> exception
      when the input stream is empty.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfilter"></a>filter : <code class="type">f:('a -> bool) -> 'a Stream.t -> 'a Stream.t</code></pre><div class="info">
<code class="code">filter test stream</code> picks all the elements satisfying <code class="code">test</code> from <code class="code">stream</code>
      and return the results in the same order as a stream.<br>
</div>
<br>
<a name="6_Computationoverstream"></a>
<h6>Computation over stream</h6>
<p>

    All the functions in this part are lazy.<br>
<pre><span class="keyword">val</span> <a name="VALmap"></a>map : <code class="type">f:('a -> 'b) -> 'a Stream.t -> 'b Stream.t</code></pre><div class="info">
<code class="code">map f stream</code> applies <code class="code">f</code> in turn to elements from <code class="code">stream</code> and return the
      results as a stream in the same order.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmap2"></a>map2 : <code class="type">f:('a -> 'b -> 'c) -> 'a Stream.t -> 'b Stream.t -> 'c Stream.t</code></pre><div class="info">
<code class="code">map2 f streama streamb</code> applies <code class="code">f</code> in turn to elements of corresponding
      positions from <code class="code">streama</code> and <code class="code">streamb</code>. The results are constructed in the
      same order as a stream. If one stream is short, excess elements of the longer
      stream are ignored.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALscanl"></a>scanl : <code class="type">f:('a -> 'b -> 'a) -> 'a -> 'b Stream.t -> 'a Stream.t</code></pre><div class="info">
<code class="code">scanl f init stream</code> returns a stream of successive reduced values from the
      left: <code class="code">scanl f init [&lt;'e1;'e2;..&gt;] = [&lt;'init; '((f init e1) as e1'); '(f
      e1' e2); ..&gt;]</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALscan"></a>scan : <code class="type">f:('a -> 'a -> 'a) -> 'a Stream.t -> 'a Stream.t</code></pre><div class="info">
<code class="code">scan</code> is similar to <code class="code">scanl</code> but without the <code class="code">init</code> value: <code class="code">scan f
      [&lt;'e1;'e2;..&gt;] = [&lt;'e1;'(f e1 e2);..&gt;]</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtake_while"></a>take_while : <code class="type">f:('a -> bool) -> 'a Stream.t -> 'a Stream.t</code></pre><div class="info">
<code class="code">take_while test stream</code> returns the longest (possibly empty) prefix of
      <code class="code">stream</code> of elements that satisfy <code class="code">test</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdrop_while"></a>drop_while : <code class="type">f:('a -> bool) -> 'a Stream.t -> 'a Stream.t</code></pre><div class="info">
<code class="code">drop_while test stream</code> returns the remaining suffix of <code class="code">take_while test
      stream</code>.<br>
</div>
<br>
<a name="6_Streamspairarithmetic"></a>
<h6>Streams pair arithmetic</h6>
<p>

    All the functions in this part are lazy.<br>
<pre><span class="keyword">val</span> <a name="VALmerge"></a>merge : <code class="type">f:(bool -> 'a -> bool) -> 'a Stream.t * 'a Stream.t -> 'a Stream.t</code></pre><div class="info">
<code class="code">merge test (streama, streamb)</code> merge the elements from <code class="code">streama</code> and
      <code class="code">streamb</code> into a single stream. The <code class="code">bool</code> type here represents the id of the
      two input streams where <code class="code">true</code> is the first and <code class="code">false</code> represents the
      second. The <code class="code">test</code> function is applied to each element of the output stream
      together with the id of the input stream from which it was extracted, to
      decide which stream should the next element come from. The first element is
      always taken from <code class="code">streama</code>. When a stream runs out of elements, the merge
      process will continue to take elements from the other stream until both
      streams reach their ends.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALswitch"></a>switch : <code class="type">f:('a -> bool) -> 'a Stream.t -> 'a Stream.t * 'a Stream.t</code></pre><div class="info">
<code class="code">switch ~f:test stream</code> split <code class="code">stream</code> into two streams, where the first stream have
      all the elements satisfying <code class="code">test</code>, the second stream is opposite. The
      order of elements in the source stream is preserved.<br>
</div>
<br>
<a name="6_Streamarithmetic"></a>
<h6>Stream arithmetic</h6> 
<p>

    All the functions in this part are lazy.<br>
</body></html>