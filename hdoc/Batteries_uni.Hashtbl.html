<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Batteries_uni.Genlex.html">
<link rel="next" href="Batteries_uni.Heap.html">
<link rel="Up" href="Batteries_uni.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="BatArg" rel="Chapter" href="BatArg.html">
<link title="BatArray" rel="Chapter" href="BatArray.html">
<link title="BatAvlTree" rel="Chapter" href="BatAvlTree.html">
<link title="BatBase64" rel="Chapter" href="BatBase64.html">
<link title="BatBig_int" rel="Chapter" href="BatBig_int.html">
<link title="BatBigarray" rel="Chapter" href="BatBigarray.html">
<link title="BatBitSet" rel="Chapter" href="BatBitSet.html">
<link title="BatBool" rel="Chapter" href="BatBool.html">
<link title="BatBuffer" rel="Chapter" href="BatBuffer.html">
<link title="BatCamomile" rel="Chapter" href="BatCamomile.html">
<link title="BatChar" rel="Chapter" href="BatChar.html">
<link title="BatCharEncodings" rel="Chapter" href="BatCharEncodings.html">
<link title="BatCharParser" rel="Chapter" href="BatCharParser.html">
<link title="BatComplex" rel="Chapter" href="BatComplex.html">
<link title="BatConcurrent" rel="Chapter" href="BatConcurrent.html">
<link title="BatDeque" rel="Chapter" href="BatDeque.html">
<link title="BatDigest" rel="Chapter" href="BatDigest.html">
<link title="BatDllist" rel="Chapter" href="BatDllist.html">
<link title="BatDynArray" rel="Chapter" href="BatDynArray.html">
<link title="BatEnum" rel="Chapter" href="BatEnum.html">
<link title="BatFile" rel="Chapter" href="BatFile.html">
<link title="BatFloat" rel="Chapter" href="BatFloat.html">
<link title="BatFormat" rel="Chapter" href="BatFormat.html">
<link title="BatGc" rel="Chapter" href="BatGc.html">
<link title="BatGenlex" rel="Chapter" href="BatGenlex.html">
<link title="BatGlobal" rel="Chapter" href="BatGlobal.html">
<link title="BatHashcons" rel="Chapter" href="BatHashcons.html">
<link title="BatHashtbl" rel="Chapter" href="BatHashtbl.html">
<link title="BatHeap" rel="Chapter" href="BatHeap.html">
<link title="BatIMap" rel="Chapter" href="BatIMap.html">
<link title="BatIO" rel="Chapter" href="BatIO.html">
<link title="BatISet" rel="Chapter" href="BatISet.html">
<link title="BatInnerIO" rel="Chapter" href="BatInnerIO.html">
<link title="BatInnerWeaktbl" rel="Chapter" href="BatInnerWeaktbl.html">
<link title="BatInt" rel="Chapter" href="BatInt.html">
<link title="BatInt32" rel="Chapter" href="BatInt32.html">
<link title="BatInt64" rel="Chapter" href="BatInt64.html">
<link title="BatInterfaces" rel="Chapter" href="BatInterfaces.html">
<link title="BatLazyList" rel="Chapter" href="BatLazyList.html">
<link title="BatLexing" rel="Chapter" href="BatLexing.html">
<link title="BatList" rel="Chapter" href="BatList.html">
<link title="BatLogger" rel="Chapter" href="BatLogger.html">
<link title="BatMap" rel="Chapter" href="BatMap.html">
<link title="BatMarshal" rel="Chapter" href="BatMarshal.html">
<link title="BatMonad" rel="Chapter" href="BatMonad.html">
<link title="BatMultiPMap" rel="Chapter" href="BatMultiPMap.html">
<link title="BatMutex" rel="Chapter" href="BatMutex.html">
<link title="BatNativeint" rel="Chapter" href="BatNativeint.html">
<link title="BatNum" rel="Chapter" href="BatNum.html">
<link title="BatNumber" rel="Chapter" href="BatNumber.html">
<link title="BatOo" rel="Chapter" href="BatOo.html">
<link title="BatOptParse" rel="Chapter" href="BatOptParse.html">
<link title="BatOption" rel="Chapter" href="BatOption.html">
<link title="BatPMap" rel="Chapter" href="BatPMap.html">
<link title="BatPSet" rel="Chapter" href="BatPSet.html">
<link title="BatPair" rel="Chapter" href="BatPair.html">
<link title="BatParserCo" rel="Chapter" href="BatParserCo.html">
<link title="BatPathGen" rel="Chapter" href="BatPathGen.html">
<link title="BatPervasives" rel="Chapter" href="BatPervasives.html">
<link title="BatPrint" rel="Chapter" href="BatPrint.html">
<link title="BatPrintexc" rel="Chapter" href="BatPrintexc.html">
<link title="BatPrintf" rel="Chapter" href="BatPrintf.html">
<link title="BatQueue" rel="Chapter" href="BatQueue.html">
<link title="BatRMutex" rel="Chapter" href="BatRMutex.html">
<link title="BatRandom" rel="Chapter" href="BatRandom.html">
<link title="BatRef" rel="Chapter" href="BatRef.html">
<link title="BatRefList" rel="Chapter" href="BatRefList.html">
<link title="BatResult" rel="Chapter" href="BatResult.html">
<link title="BatReturn" rel="Chapter" href="BatReturn.html">
<link title="BatRope" rel="Chapter" href="BatRope.html">
<link title="BatScanf" rel="Chapter" href="BatScanf.html">
<link title="BatSeq" rel="Chapter" href="BatSeq.html">
<link title="BatSet" rel="Chapter" href="BatSet.html">
<link title="BatStack" rel="Chapter" href="BatStack.html">
<link title="BatStd" rel="Chapter" href="BatStd.html">
<link title="BatStr" rel="Chapter" href="BatStr.html">
<link title="BatStream" rel="Chapter" href="BatStream.html">
<link title="BatString" rel="Chapter" href="BatString.html">
<link title="BatSubstring" rel="Chapter" href="BatSubstring.html">
<link title="BatSys" rel="Chapter" href="BatSys.html">
<link title="BatUChar" rel="Chapter" href="BatUChar.html">
<link title="BatUCharParser" rel="Chapter" href="BatUCharParser.html">
<link title="BatUTF8" rel="Chapter" href="BatUTF8.html">
<link title="BatUnit" rel="Chapter" href="BatUnit.html">
<link title="BatUnix" rel="Chapter" href="BatUnix.html">
<link title="BatUref" rel="Chapter" href="BatUref.html">
<link title="BatValue_printer" rel="Chapter" href="BatValue_printer.html">
<link title="BatVect" rel="Chapter" href="BatVect.html">
<link title="Batteries" rel="Chapter" href="Batteries.html">
<link title="Batteries_config" rel="Chapter" href="Batteries_config.html">
<link title="Batteries_print" rel="Chapter" href="Batteries_print.html">
<link title="Batteries_uni" rel="Chapter" href="Batteries_uni.html"><link title="Base operations" rel="Section" href="#6_Baseoperations">
<link title="Enumerations" rel="Section" href="#6_Enumerations">
<link title="Searching" rel="Section" href="#6_Searching">
<link title="Traversing" rel="Section" href="#6_Traversing">
<link title="The polymorphic hash primitive" rel="Section" href="#6_Thepolymorphichashprimitive">
<link title="Boilerplate code" rel="Section" href="#6_Boilerplatecode">
<link title="Override modules" rel="Section" href="#6_Overridemodules">
<link title="Functorial interface" rel="Section" href="#6_Functorialinterface">
<link title="Printing" rel="Subsection" href="#7_Printing">
<title>Batteries_uni.Hashtbl</title>
</head>
<body>
<div class="navbar"><a href="Batteries_uni.Genlex.html">Previous</a>
&nbsp;<a href="Batteries_uni.html">Up</a>
&nbsp;<a href="Batteries_uni.Heap.html">Next</a>
</div>
<center><h1>Module <a href="type_Batteries_uni.Hashtbl.html">Batteries_uni.Hashtbl</a></h1></center>
<br>
<pre><span class="keyword">module</span> Hashtbl: <code class="type">BatHashtbl</code></pre><hr width="100%">
<br>
Operations over hashtables. 
<p>

    This module replaces Stdlib's
    <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Hashtbl.html">Hashtbl</a>
    module.  All functions and types are provided here.<br>
<pre><span class="keyword">type</span> <a name="TYPEt"></a><code class="type">('a, 'b)</code> t = <code class="type">('a, 'b) Hashtbl.t</code> </pre>
<div class="info">
A Hashtable wth keys of type 'a and values 'b<br>
</div>

<br>
<a name="6_Baseoperations"></a>
<h6>Base operations</h6><br>
<pre><span class="keyword">val</span> <a name="VALcreate"></a>create : <code class="type">int -> ('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">Hashtbl.create n</code> creates a new, empty hash table, with
   initial size <code class="code">n</code>.  For best results, <code class="code">n</code> should be on the
   order of the expected number of elements that will be in
   the table.  The table grows as needed, so <code class="code">n</code> is just an
   initial guess.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALlength"></a>length : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> int</code></pre><div class="info">
<code class="code">Hashtbl.length tbl</code> returns the number of bindings in <code class="code">tbl</code>.
   Multiple bindings are counted multiply, so <code class="code">Hashtbl.length</code>
   gives the number of times <code class="code">Hashtbl.iter</code> calls its first argument.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALis_empty"></a>is_empty : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> bool</code></pre><div class="info">
<code class="code">Hashtbl.is_empty tbl</code> returns <code class="code">true</code> if there are no bindings
      in <code class="code">tbl</code>, false otherwise.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALadd"></a>add : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'a -> 'b -> unit</code></pre><div class="info">
<code class="code">Hashtbl.add tbl x y</code> adds a binding of <code class="code">x</code> to <code class="code">y</code> in table <code class="code">tbl</code>.
   Previous bindings for <code class="code">x</code> are not removed, but simply
   hidden. That is, after performing <code class="code">Hashtbl.remove</code><code class="code"> tbl x</code>,
   the previous binding for <code class="code">x</code>, if any, is restored.
   (Same behavior as with association lists.)<br>
</div>
<pre><span class="keyword">val</span> <a name="VALremove"></a>remove : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'a -> unit</code></pre><div class="info">
<code class="code">Hashtbl.remove tbl x</code> removes the current binding of <code class="code">x</code> in <code class="code">tbl</code>,
   restoring the previous binding if it exists.
   It does nothing if <code class="code">x</code> is not bound in <code class="code">tbl</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALremove_all"></a>remove_all : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'a -> unit</code></pre><div class="info">
Remove all bindings for the given key<br>
</div>
<pre><span class="keyword">val</span> <a name="VALreplace"></a>replace : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'a -> 'b -> unit</code></pre><div class="info">
<code class="code">Hashtbl.replace tbl x y</code> replaces the current binding of <code class="code">x</code>
   in <code class="code">tbl</code> by a binding of <code class="code">x</code> to <code class="code">y</code>.  If <code class="code">x</code> is unbound in <code class="code">tbl</code>,
   a binding of <code class="code">x</code> to <code class="code">y</code> is added to <code class="code">tbl</code>.
   This is functionally equivalent to <code class="code">Hashtbl.remove</code><code class="code"> tbl x</code>
   followed by <code class="code">Hashtbl.add</code><code class="code"> tbl x y</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcopy"></a>copy : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> ('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a></code></pre><div class="info">
Return a copy of the given hashtable.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALclear"></a>clear : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> unit</code></pre><div class="info">
Empty a hash table.<br>
</div>
<br>
<a name="6_Enumerations"></a>
<h6>Enumerations</h6><br>
<pre><span class="keyword">val</span> <a name="VALkeys"></a>keys : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'a <a href="BatEnum.html#TYPEt">BatEnum.t</a></code></pre><div class="info">
Return an enumeration of all the keys of a hashtable.
      If the key is in the Hashtable multiple times, all occurrences
      will be returned.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvalues"></a>values : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'b <a href="BatEnum.html#TYPEt">BatEnum.t</a></code></pre><div class="info">
Return an enumeration of all the values of a hashtable.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALenum"></a>enum : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> ('a * 'b) <a href="BatEnum.html#TYPEt">BatEnum.t</a></code></pre><div class="info">
Return an enumeration of (key,value) pairs of a hashtable.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALof_enum"></a>of_enum : <code class="type">('a * 'b) <a href="BatEnum.html#TYPEt">BatEnum.t</a> -> ('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a></code></pre><div class="info">
Create a hashtable from a (key,value) enumeration.<br>
</div>
<br>
<a name="6_Searching"></a>
<h6>Searching</h6><br>
<pre><span class="keyword">val</span> <a name="VALfind"></a>find : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'a -> 'b</code></pre><div class="info">
<code class="code">Hashtbl.find tbl x</code> returns the current binding of <code class="code">x</code> in <code class="code">tbl</code>,
   or raises <code class="code">Not_found</code> if no such binding exists.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfind_all"></a>find_all : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'a -> 'b list</code></pre><div class="info">
<code class="code">Hashtbl.find_all tbl x</code> returns the list of all data
   associated with <code class="code">x</code> in <code class="code">tbl</code>.
   The current binding is returned first, then the previous
   bindings, in reverse order of introduction in the table.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfind_default"></a>find_default : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'a -> 'b -> 'b</code></pre><div class="info">
Find a binding for the key, and return a default
      value if not found<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfind_option"></a>find_option : <code class="type">('a, 'b) Hashtbl.t -> 'a -> 'b option</code></pre><div class="info">
Find a binding for the key, or return <code class="code">None</code> if no
      value is found<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmem"></a>mem : <code class="type">('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'a -> bool</code></pre><div class="info">
<code class="code">Hashtbl.mem tbl x</code> checks if <code class="code">x</code> is bound in <code class="code">tbl</code>.<br>
</div>
<br>
<code class="code">exists h k</code> returns true is at least one item with key <code class="code">k</code> is
      found in the hashtable.<br>
<br>
<a name="6_Traversing"></a>
<h6>Traversing</h6>
<p>

   A number of higher-order functions are provided to allow
   purely functional traversal or transformation of hashtables.
   These functions are similar to their counterparts in module
   <a href="BatEnum.html"><code class="code">BatEnum</code></a>.
<p>

   Whenever you wish to traverse or transfor a hashtable, you have the
   choice between using the more general functions of <a href="BatEnum.html"><code class="code">BatEnum</code></a>, with
   <a href="BatHashtbl.html#VALkeys"><code class="code">BatHashtbl.keys</code></a>, <a href="BatHashtbl.html#VALvalues"><code class="code">BatHashtbl.values</code></a>, <a href="BatHashtbl.html#VALenum"><code class="code">BatHashtbl.enum</code></a> and <a href="BatHashtbl.html#VALof_enum"><code class="code">BatHashtbl.of_enum</code></a>, or the more optimized
   functions of this section.
<p>

   If you are new to OCaml or unsure about data structure, using the
   functions of <a href="BatEnum.html"><code class="code">BatEnum</code></a> is a safe bet. Should you wish to improve
   performance at the cost of generality, you will always be able to
   rewrite your code to make use of the functions of this section.<br>
<pre><span class="keyword">val</span> <a name="VALiter"></a>iter : <code class="type">('a -> 'b -> unit) -> ('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> unit</code></pre><div class="info">
<code class="code">Hashtbl.iter f tbl</code> applies <code class="code">f</code> to all bindings in table <code class="code">tbl</code>.
      <code class="code">f</code> receives the key as first argument, and the associated value
      as second argument. Each binding is presented exactly once to <code class="code">f</code>.
      The order in which the bindings are passed to <code class="code">f</code> is unspecified.
      However, if the table contains several bindings for the same key,
      they are passed to <code class="code">f</code> in reverse order of introduction, that is,
      the most recent binding is passed first.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold"></a>fold : <code class="type">('a -> 'b -> 'c -> 'c) -> ('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> 'c -> 'c</code></pre><div class="info">
<code class="code">Hashtbl.fold f tbl init</code> computes
   <code class="code">(f kN dN ... (f k1 d1 (f k0 d0 init))...)</code>,
   where <code class="code">k0,k1..kN</code> are the keys of all bindings in <code class="code">tbl</code>,
   and <code class="code">d0,d1..dN</code> are the associated values.
   Each binding is presented exactly once to <code class="code">f</code>.
   The order in which the bindings are passed to <code class="code">f</code> is unspecified.
   However, if the table contains several bindings for the same key,
   they are passed to <code class="code">f</code> in reverse order of introduction, that is,
   the most recent binding is passed first.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmap"></a>map : <code class="type">('a -> 'b -> 'c) -> ('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> ('a, 'c) <a href="BatHashtbl.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">map f x</code> creates a new hashtable with the same
      keys as <code class="code">x</code>, but with the function <code class="code">f</code> applied to
      all the values<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfilter"></a>filter : <code class="type">('a -> bool) -> ('b, 'a) <a href="BatHashtbl.html#TYPEt">t</a> -> ('b, 'a) <a href="BatHashtbl.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">filter f m</code> returns a new hashtable where only the values <code class="code">a</code> of <code class="code">m</code>
     such that <code class="code">f a = true</code> remain.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfilteri"></a>filteri : <code class="type">('a -> 'b -> bool) -> ('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> ('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">filter f m</code> returns a map where only the key, values pairs
     <code class="code">key</code>, <code class="code">a</code> of <code class="code">m</code> such that <code class="code">f key a = true</code> remain. The
     bindings are passed to <code class="code">f</code> in increasing order with respect
     to the ordering over the type of the keys.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfilter_map"></a>filter_map : <code class="type">('a -> 'b -> 'c option) -> ('a, 'b) <a href="BatHashtbl.html#TYPEt">t</a> -> ('a, 'c) <a href="BatHashtbl.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">filter_map f m</code> combines the features of <code class="code">filteri</code> and
      <code class="code">map</code>.  It calls <code class="code">f key0 a0</code>, <code class="code">f key1 a1</code>, <code class="code">f keyn an</code>
      where <code class="code">a0,a1..an</code> are the elements of <code class="code">m</code> and <code class="code">key0..keyn</code> the
      respective corresponding keys. It returns the map of
      pairs <code class="code">keyi</code>,<code class="code">bi</code> such as <code class="code">f keyi ai = Some bi</code> (when <code class="code">f</code> returns
      <code class="code">None</code>, the corresponding element of <code class="code">m</code> is discarded).<br>
</div>
<br>
<a name="6_Thepolymorphichashprimitive"></a>
<h6>The polymorphic hash primitive</h6><br>
<pre><span class="keyword">val</span> <a name="VALhash"></a>hash : <code class="type">'a -> int</code></pre><div class="info">
<code class="code">Hashtbl.hash x</code> associates a positive integer to any value of
   any type. It is guaranteed that
   if <code class="code">x = y</code> or <code class="code">Pervasives.compare x y = 0</code>, then <code class="code">hash x = hash y</code>.
   Moreover, <code class="code">hash</code> always terminates, even on cyclic
   structures.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALhash_param"></a>hash_param : <code class="type">int -> int -> 'a -> int</code></pre><div class="info">
<code class="code">Hashtbl.hash_param n m x</code> computes a hash value for <code class="code">x</code>, with the
   same properties as for <code class="code">hash</code>. The two extra parameters <code class="code">n</code> and
   <code class="code">m</code> give more precise control over hashing. Hashing performs a
   depth-first, right-to-left traversal of the structure <code class="code">x</code>, stopping
   after <code class="code">n</code> meaningful nodes were encountered, or <code class="code">m</code> nodes,
   meaningful or not, were encountered. Meaningful nodes are: integers;
   floating-point numbers; strings; characters; booleans; and constant
   constructors. Larger values of <code class="code">m</code> and <code class="code">n</code> means that more
   nodes are taken into account to compute the final hash
   value, and therefore collisions are less likely to happen.
   However, hashing takes longer. The parameters <code class="code">m</code> and <code class="code">n</code>
   govern the tradeoff between accuracy and speed.<br>
</div>
<br>
<a name="6_Boilerplatecode"></a>
<h6>Boilerplate code</h6><br>
<br>
<a name="7_Printing"></a>
<div class="h7">Printing</div><br>
<pre><span class="keyword">val</span> <a name="VALprint"></a>print : <code class="type">?first:string -><br>       ?last:string -><br>       ?sep:string -><br>       ('a <a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> -> 'b -> unit) -><br>       ('a <a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> -> 'c -> unit) -><br>       'a <a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> -> ('b, 'c) <a href="BatHashtbl.html#TYPEt">t</a> -> unit</code></pre><br>
<a name="6_Overridemodules"></a>
<h6>Override modules</h6><br>
<br>
The following modules replace functions defined in <code class="code">Hashtbl</code> with functions
       behaving slightly differently but having the same name. This is by design:
       the functions meant to override the corresponding functions of <code class="code">Hashtbl</code>.<br>
<pre><span class="keyword">module</span> <a href="BatHashtbl.Exceptionless.html">Exceptionless</a>: <code class="code">sig</code> <a href="BatHashtbl.Exceptionless.html">..</a> <code class="code">end</code></pre><div class="info">
Operations on <code class="code">Hashtbl</code> without exceptions.
</div>
<pre><span class="keyword">module</span> <a href="BatHashtbl.Infix.html">Infix</a>: <code class="code">sig</code> <a href="BatHashtbl.Infix.html">..</a> <code class="code">end</code></pre><div class="info">
Infix operators over a <a href="BatHashtbl.html"><code class="code">BatHashtbl</code></a>
</div>
<pre><span class="keyword">module</span> <a href="BatHashtbl.Labels.html">Labels</a>: <code class="code">sig</code> <a href="BatHashtbl.Labels.html">..</a> <code class="code">end</code></pre><div class="info">
Operations on <code class="code">Hashtbl</code> with labels.
</div>
<br>
<a name="6_Functorialinterface"></a>
<h6>Functorial interface</h6><br>
<pre><span class="keyword">module type</span> <a href="BatHashtbl.HashedType.html">HashedType</a> = <code class="code">sig</code> <a href="BatHashtbl.HashedType.html">..</a> <code class="code">end</code></pre><pre><span class="keyword">module type</span> <a href="BatHashtbl.S.html">S</a> = <code class="code">sig</code> <a href="BatHashtbl.S.html">..</a> <code class="code">end</code></pre><div class="info">
The output signature of the functor <code class="code">Hashtbl.Make</code>.
</div>
<pre><span class="keyword">module</span> <a href="BatHashtbl.Make.html">Make</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">H</code><code class="code"> : </code><code class="type"><a href="BatHashtbl.HashedType.html">HashedType</a></code><code class="code">) -&gt; </code><code class="type"><a href="BatHashtbl.S.html">S</a></code><code class="type">  with type key = H.t</code></div></pre><div class="info">
Functor building an implementation of the hashtable structure.
</div>
<pre><span class="keyword">module</span> <a href="BatHashtbl.Cap.html">Cap</a>: <code class="code">sig</code> <a href="BatHashtbl.Cap.html">..</a> <code class="code">end</code></pre><div class="info">
Capabilities for hashtables.
</div>
</body></html>