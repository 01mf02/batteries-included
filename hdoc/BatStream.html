<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="BatStr.html">
<link rel="next" href="BatString.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="BatArg" rel="Chapter" href="BatArg.html">
<link title="BatArray" rel="Chapter" href="BatArray.html">
<link title="BatAvlTree" rel="Chapter" href="BatAvlTree.html">
<link title="BatBase64" rel="Chapter" href="BatBase64.html">
<link title="BatBig_int" rel="Chapter" href="BatBig_int.html">
<link title="BatBigarray" rel="Chapter" href="BatBigarray.html">
<link title="BatBitSet" rel="Chapter" href="BatBitSet.html">
<link title="BatBool" rel="Chapter" href="BatBool.html">
<link title="BatBuffer" rel="Chapter" href="BatBuffer.html">
<link title="BatCamomile" rel="Chapter" href="BatCamomile.html">
<link title="BatChar" rel="Chapter" href="BatChar.html">
<link title="BatCharEncodings" rel="Chapter" href="BatCharEncodings.html">
<link title="BatCharParser" rel="Chapter" href="BatCharParser.html">
<link title="BatComplex" rel="Chapter" href="BatComplex.html">
<link title="BatConcurrent" rel="Chapter" href="BatConcurrent.html">
<link title="BatDigest" rel="Chapter" href="BatDigest.html">
<link title="BatDllist" rel="Chapter" href="BatDllist.html">
<link title="BatDynArray" rel="Chapter" href="BatDynArray.html">
<link title="BatEnum" rel="Chapter" href="BatEnum.html">
<link title="BatFile" rel="Chapter" href="BatFile.html">
<link title="BatFloat" rel="Chapter" href="BatFloat.html">
<link title="BatFormat" rel="Chapter" href="BatFormat.html">
<link title="BatGc" rel="Chapter" href="BatGc.html">
<link title="BatGenlex" rel="Chapter" href="BatGenlex.html">
<link title="BatGlobal" rel="Chapter" href="BatGlobal.html">
<link title="BatHashtbl" rel="Chapter" href="BatHashtbl.html">
<link title="BatIMap" rel="Chapter" href="BatIMap.html">
<link title="BatIO" rel="Chapter" href="BatIO.html">
<link title="BatISet" rel="Chapter" href="BatISet.html">
<link title="BatInnerIO" rel="Chapter" href="BatInnerIO.html">
<link title="BatInnerWeaktbl" rel="Chapter" href="BatInnerWeaktbl.html">
<link title="BatInt" rel="Chapter" href="BatInt.html">
<link title="BatInt32" rel="Chapter" href="BatInt32.html">
<link title="BatInt64" rel="Chapter" href="BatInt64.html">
<link title="BatInterfaces" rel="Chapter" href="BatInterfaces.html">
<link title="BatLazyList" rel="Chapter" href="BatLazyList.html">
<link title="BatLexing" rel="Chapter" href="BatLexing.html">
<link title="BatList" rel="Chapter" href="BatList.html">
<link title="BatLogger" rel="Chapter" href="BatLogger.html">
<link title="BatMap" rel="Chapter" href="BatMap.html">
<link title="BatMarshal" rel="Chapter" href="BatMarshal.html">
<link title="BatMonad" rel="Chapter" href="BatMonad.html">
<link title="BatMultiPMap" rel="Chapter" href="BatMultiPMap.html">
<link title="BatMutex" rel="Chapter" href="BatMutex.html">
<link title="BatNativeint" rel="Chapter" href="BatNativeint.html">
<link title="BatNum" rel="Chapter" href="BatNum.html">
<link title="BatNumber" rel="Chapter" href="BatNumber.html">
<link title="BatOo" rel="Chapter" href="BatOo.html">
<link title="BatOptParse" rel="Chapter" href="BatOptParse.html">
<link title="BatOption" rel="Chapter" href="BatOption.html">
<link title="BatPMap" rel="Chapter" href="BatPMap.html">
<link title="BatPSet" rel="Chapter" href="BatPSet.html">
<link title="BatPair" rel="Chapter" href="BatPair.html">
<link title="BatParserCo" rel="Chapter" href="BatParserCo.html">
<link title="BatPathGen" rel="Chapter" href="BatPathGen.html">
<link title="BatPervasives" rel="Chapter" href="BatPervasives.html">
<link title="BatPrint" rel="Chapter" href="BatPrint.html">
<link title="BatPrintexc" rel="Chapter" href="BatPrintexc.html">
<link title="BatPrintf" rel="Chapter" href="BatPrintf.html">
<link title="BatQueue" rel="Chapter" href="BatQueue.html">
<link title="BatRMutex" rel="Chapter" href="BatRMutex.html">
<link title="BatRandom" rel="Chapter" href="BatRandom.html">
<link title="BatRef" rel="Chapter" href="BatRef.html">
<link title="BatRefList" rel="Chapter" href="BatRefList.html">
<link title="BatResult" rel="Chapter" href="BatResult.html">
<link title="BatReturn" rel="Chapter" href="BatReturn.html">
<link title="BatRope" rel="Chapter" href="BatRope.html">
<link title="BatScanf" rel="Chapter" href="BatScanf.html">
<link title="BatSeq" rel="Chapter" href="BatSeq.html">
<link title="BatSet" rel="Chapter" href="BatSet.html">
<link title="BatStack" rel="Chapter" href="BatStack.html">
<link title="BatStd" rel="Chapter" href="BatStd.html">
<link title="BatStr" rel="Chapter" href="BatStr.html">
<link title="BatStream" rel="Chapter" href="BatStream.html">
<link title="BatString" rel="Chapter" href="BatString.html">
<link title="BatSubstring" rel="Chapter" href="BatSubstring.html">
<link title="BatSys" rel="Chapter" href="BatSys.html">
<link title="BatUChar" rel="Chapter" href="BatUChar.html">
<link title="BatUCharParser" rel="Chapter" href="BatUCharParser.html">
<link title="BatUTF8" rel="Chapter" href="BatUTF8.html">
<link title="BatUnit" rel="Chapter" href="BatUnit.html">
<link title="BatUnix" rel="Chapter" href="BatUnix.html">
<link title="BatValue_printer" rel="Chapter" href="BatValue_printer.html">
<link title="BatVect" rel="Chapter" href="BatVect.html">
<link title="Batteries" rel="Chapter" href="Batteries.html">
<link title="Batteries_config" rel="Chapter" href="Batteries_config.html">
<link title="Batteries_print" rel="Chapter" href="Batteries_print.html">
<link title="Batteries_uni" rel="Chapter" href="Batteries_uni.html"><link title="Conversion functions" rel="Section" href="#6_Conversionfunctions">
<link title="Stream consumers" rel="Section" href="#6_Streamconsumers">
<link title="Stream builders" rel="Section" href="#6_Streambuilders">
<link title="Other constructors" rel="Section" href="#6_Otherconstructors">
<link title="Stream iterators" rel="Section" href="#6_Streamiterators">
<link title="Computation over stream" rel="Section" href="#6_Computationoverstream">
<link title="Streams pair arithmetic" rel="Section" href="#6_Streamspairarithmetic">
<link title="Stream arithmetic" rel="Section" href="#6_Streamarithmetic">
<link title="Predefined parsers" rel="Section" href="#6_Predefinedparsers">
<title>BatStream</title>
</head>
<body>
<div class="navbar"><a href="BatStr.html">Previous</a>
&nbsp;<a href="index.html">Up</a>
&nbsp;<a href="BatString.html">Next</a>
</div>
<center><h1>Module <a href="type_BatStream.html">BatStream</a></h1></center>
<br>
<pre><span class="keyword">module</span> BatStream: <code class="code">sig</code> <a href="BatStream.html">..</a> <code class="code">end</code></pre>Streams and stream parsers
<p>

   <b>Note</b> This module is provided essentially for backwards-compatibility.
   If you feel like using <code class="code">Stream.t</code>, please take a look at <code class="code">BatEnum</code>
   or <code class="code">LazyList</code>.
<p>

   This module is based on <a href="http://www.pps.jussieu.fr/~li/software/sdflow/">Zheng Li's SDFlow</a>
<p>

    This module extends Stdlib's
    <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Stream.html">Stream</a>
    module, go there for documentation on the rest of the functions
    and types.<br>
<hr width="100%">
<br>
Streams and parsers. 
<p>

    Streams are a read-and-forget data structure, comparable to enumerations.
    In Batteries Included, streams are deprecated in favor of enumerations,
    defined in module <a href="BatEnum.html"><code class="code">BatEnum</code></a>.<br>
<pre><span class="keyword">include</span> <a href="BatEnum.Enumerable.html">BatEnum.Enumerable</a></pre>
<pre><span class="keyword">include</span> <a href="BatInterfaces.Mappable.html">BatInterfaces.Mappable</a></pre>
<br>
<a name="6_Conversionfunctions"></a>
<h6>Conversion functions</h6><br>
<pre><span class="keyword">val</span> <a name="VALenum"></a>enum : <code class="type">'a Stream.t -> 'a <a href="BatEnum.html#TYPEt">BatEnum.t</a></code></pre><div class="info">
Convert an enumeration to a stream.
    Reading the resulting stream will consume elements from the enumeration.
    This is the preferred manner of creating a stream.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALof_enum"></a>of_enum : <code class="type">'a <a href="BatEnum.html#TYPEt">BatEnum.t</a> -> 'a Stream.t</code></pre><div class="info">
Convert a stream to an enumeration.
    Reading the resulting enumeration will consume elements from the stream.
    This is the preferred manner of converting from a stream to any other
    data structure.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALof_input"></a>of_input : <code class="type"><a href="BatIO.html#TYPEinput">BatIO.input</a> -> char Stream.t</code></pre><div class="info">
Convert an <code class="code">input</code> to a stream.<br>
</div>
<br>
<a name="6_Streamconsumers"></a>
<h6>Stream consumers</h6><br>
<pre><span class="keyword">val</span> <a name="VALon_output"></a>on_output : <code class="type">'a <a href="BatIO.html#TYPEoutput">BatIO.output</a> -> char Stream.t -> unit</code></pre><div class="info">
Convert an <code class="code">output</code> to a stream.<br>
</div>
<br>
<a name="6_Streambuilders"></a>
<h6>Stream builders</h6>
<p>

   Warning: these functions create streams with fast access; it is illegal
   to mix them with streams built with <code class="code">[&lt; &gt;]</code>; would raise <code class="code">Failure</code>
   when accessing such mixed streams.<br>
<br>
<a name="6_Otherconstructors"></a>
<h6>Other constructors</h6><br>
<pre><span class="keyword">val</span> <a name="VALof_fun"></a>of_fun : <code class="type">(unit -> 'a) -> 'a Stream.t</code></pre><div class="info">
<code class="code">Stream.from f</code> returns a stream built from the function <code class="code">f</code>.
   To create a new stream element, the function <code class="code">f</code> is called with
   the current stream count. The user function <code class="code">f</code> must return either
   <code class="code">Some &lt;value&gt;</code> for a value or <code class="code">None</code> to specify the end of the
   stream.<br>
</div>
<br>
<a name="6_Streamiterators"></a>
<h6>Stream iterators</h6><br>
<pre><span class="keyword">val</span> <a name="VALfoldl"></a>foldl : <code class="type">('a -> 'b -> 'a * bool option) -> 'a -> 'b Stream.t -> 'a</code></pre><div class="info">
<code class="code">foldl f init stream</code> is a lazy fold_left. <code class="code">f accu elt</code> should return
      <code class="code">(new_accu, state)</code> where <code class="code">new_accu</code> is normal accumulation result, and
      <code class="code">state</code> is a flag representing whether the computation should continue
      and whether the last operation is valid: <code class="code">None</code> means continue, <code class="code">Some b</code>
      means stop where <code class="code">b = true</code> means the last addition is still valid and <code class="code">b
      = false</code> means the last addition is invalid and should be revert.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfoldr"></a>foldr : <code class="type">('a -> 'b lazy_t -> 'b) -> 'b -> 'a Stream.t -> 'b</code></pre><div class="info">
<code class="code">foldr f init stream</code> is a lazy fold_right. Unlike the normal fold_right,
      the accumulation parameter of <code class="code">f elt accu</code> is lazy, hence it can decide
      not to force the evaluation of <code class="code">accu</code> if the current element <code class="code">elt</code> can
      determin the result by itself.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold"></a>fold : <code class="type">('a -> 'a -> 'a * bool option) -> 'a Stream.t -> 'a</code></pre><div class="info">
<code class="code">fold</code> is <code class="code">foldl</code> without initialization value, where the first
      element of stream is taken as <code class="code">init</code>. It raises <code class="code">End_of_stream</code> exception
      when the input stream is empty.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfilter"></a>filter : <code class="type">('a -> bool) -> 'a Stream.t -> 'a Stream.t</code></pre><div class="info">
<code class="code">filter test stream</code> picks all the elements satisfying <code class="code">test</code> from <code class="code">stream</code>
      and return the results in the same order as a stream.<br>
</div>
<br>
<a name="6_Computationoverstream"></a>
<h6>Computation over stream</h6>
<p>

    All the functions in this part are lazy.<br>
<pre><span class="keyword">val</span> <a name="VALmap"></a>map : <code class="type">('a -> 'b) -> 'a Stream.t -> 'b Stream.t</code></pre><div class="info">
<code class="code">map f stream</code> applies <code class="code">f</code> in turn to elements from <code class="code">stream</code> and return the
      results as a stream in the same order.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmap2"></a>map2 : <code class="type">('a -> 'b -> 'c) -> 'a Stream.t -> 'b Stream.t -> 'c Stream.t</code></pre><div class="info">
<code class="code">map2 f streama streamb</code> applies <code class="code">f</code> in turn to elements of corresponding
      positions from <code class="code">streama</code> and <code class="code">streamb</code>. The results are constructed in the
      same order as a stream. If one stream is short, excess elements of the longer
      stream are ignored.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALscanl"></a>scanl : <code class="type">('a -> 'b -> 'a) -> 'a -> 'b Stream.t -> 'a Stream.t</code></pre><div class="info">
<code class="code">scanl f init stream</code> returns a stream of successive reduced values from the
      left: <code class="code">scanl f init [&lt;'e1;'e2;..&gt;] = [&lt;'init; '((f init e1) as e1'); '(f
      e1' e2); ..&gt;]</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALscan"></a>scan : <code class="type">('a -> 'a -> 'a) -> 'a Stream.t -> 'a Stream.t</code></pre><div class="info">
<code class="code">scan</code> is similar to <code class="code">scanl</code> but without the <code class="code">init</code> value: <code class="code">scan f
      [&lt;'e1;'e2;..&gt;] = [&lt;'e1;'(f e1 e2);..&gt;]</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconcat"></a>concat : <code class="type">'a Stream.t Stream.t -> 'a Stream.t</code></pre><div class="info">
concatenate a stream of streams<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtake"></a>take : <code class="type">int -> 'a Stream.t -> 'a Stream.t</code></pre><div class="info">
<code class="code">take n stream</code> returns the prefix of <code class="code">stream</code> of length <code class="code">n</code>, or <code class="code">stream</code>
      itself if <code class="code">n</code> is greater than the length of <code class="code">stream</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALdrop"></a>drop : <code class="type">int -> 'a Stream.t -> 'a Stream.t</code></pre><div class="info">
<code class="code">drop n stream</code> returns the suffix of <code class="code">stream</code> after the first <code class="code">n</code> elements,
      or a empty stream if <code class="code">n</code> is greater than the length of <code class="code">stream</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALtake_while"></a>take_while : <code class="type">('a -> bool) -> 'a Stream.t -> 'a Stream.t</code></pre><div class="info">
<code class="code">take_while test stream</code> returns the longest (possibly empty) prefix of
      <code class="code">stream</code> of elements that satisfy <code class="code">test</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdrop_while"></a>drop_while : <code class="type">('a -> bool) -> 'a Stream.t -> 'a Stream.t</code></pre><div class="info">
<code class="code">drop_while test stream</code> returns the remaining suffix of <code class="code">take_while test
      stream</code>.<br>
</div>
<br>
<a name="6_Streamspairarithmetic"></a>
<h6>Streams pair arithmetic</h6>
<p>

    All the functions in this part are lazy.<br>
<pre><span class="keyword">val</span> <a name="VALdup"></a>dup : <code class="type">'a Stream.t -> 'a Stream.t * 'a Stream.t</code></pre><div class="info">
<code class="code">dup stream</code> returns a pair of streams which are identical to <code class="code">stream</code>. Note
      that stream is a destructive data structure, the point of <code class="code">dup</code> is to
      return two streams can be used independently.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcomb"></a>comb : <code class="type">'a Stream.t * 'b Stream.t -> ('a * 'b) Stream.t</code></pre><div class="info">
<code class="code">comb</code> transform a pair of stream into a stream of pairs of corresponding
      elements. If one stream is short, excess elements of the longer stream are
      ignored.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsplit"></a>split : <code class="type">('a * 'b) Stream.t -> 'a Stream.t * 'b Stream.t</code></pre><div class="info">
<code class="code">split</code> is the opposite of <code class="code">comb</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALmerge"></a>merge : <code class="type">(bool -> 'a -> bool) -> 'a Stream.t * 'a Stream.t -> 'a Stream.t</code></pre><div class="info">
<code class="code">merge test (streama, streamb)</code> merge the elements from <code class="code">streama</code> and
      <code class="code">streamb</code> into a single stream. The <code class="code">bool</code> type here represents the id of the
      two input streams where <code class="code">true</code> is the first and <code class="code">false</code> represents the
      second. The <code class="code">test</code> function is applied to each element of the output stream
      together with the id of the input stream from which it was extracted, to
      decide which stream should the next element come from. The first element is
      always taken from <code class="code">streama</code>. When a stream runs out of elements, the merge
      process will continue to take elements from the other stream until both
      streams reach their ends.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALswitch"></a>switch : <code class="type">('a -> bool) -> 'a Stream.t -> 'a Stream.t * 'a Stream.t</code></pre><div class="info">
<code class="code">switch test stream</code> split <code class="code">stream</code> into two streams, where the first stream have
      all the elements satisfying <code class="code">test</code>, the second stream is opposite. The
      order of elements in the source stream is preserved.<br>
</div>
<br>
<a name="6_Streamarithmetic"></a>
<h6>Stream arithmetic</h6> 
<p>

    All the functions in this part are lazy.<br>
<pre><span class="keyword">val</span> <a name="VALcons"></a>cons : <code class="type">'a -> 'a Stream.t -> 'a Stream.t</code></pre><div class="info">
<code class="code">cons x stream</code> equals <code class="code">[&lt;'x; stream&gt;]</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALapnd"></a>apnd : <code class="type">'a Stream.t -> 'a Stream.t -> 'a Stream.t</code></pre><div class="info">
<code class="code">apnd fla flb</code> equals <code class="code">[&lt;fla;flb&gt;]</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALis_empty"></a>is_empty : <code class="type">'a Stream.t -> bool</code></pre><div class="info">
<code class="code">is_empty stream</code> tests whether <code class="code">stream</code> is empty. But note that it forces
      the evaluation of the head element if any.<br>
</div>
<br>
<a name="6_Predefinedparsers"></a>
<h6>Predefined parsers</h6><br>
<pre><span class="keyword">val</span> <a name="VALnext"></a>next : <code class="type">'a Stream.t -> 'a</code></pre><div class="info">
Return the first element of the stream and remove it from the
   stream. Raise Stream.Failure if the stream is empty.<br>
</div>
<pre><span class="keyword">module</span> <a href="BatStream.StreamLabels.html">StreamLabels</a>: <code class="code">sig</code> <a href="BatStream.StreamLabels.html">..</a> <code class="code">end</code></pre></body></html>