<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Batteries_uni.Random.html">
<link rel="next" href="Batteries_uni.Set.html">
<link rel="Up" href="Batteries_uni.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="BatArg" rel="Chapter" href="BatArg.html">
<link title="BatArray" rel="Chapter" href="BatArray.html">
<link title="BatAvlTree" rel="Chapter" href="BatAvlTree.html">
<link title="BatBase64" rel="Chapter" href="BatBase64.html">
<link title="BatBig_int" rel="Chapter" href="BatBig_int.html">
<link title="BatBigarray" rel="Chapter" href="BatBigarray.html">
<link title="BatBitSet" rel="Chapter" href="BatBitSet.html">
<link title="BatBool" rel="Chapter" href="BatBool.html">
<link title="BatBuffer" rel="Chapter" href="BatBuffer.html">
<link title="BatCache" rel="Chapter" href="BatCache.html">
<link title="BatCamomile" rel="Chapter" href="BatCamomile.html">
<link title="BatChar" rel="Chapter" href="BatChar.html">
<link title="BatCharEncodings" rel="Chapter" href="BatCharEncodings.html">
<link title="BatCharParser" rel="Chapter" href="BatCharParser.html">
<link title="BatComplex" rel="Chapter" href="BatComplex.html">
<link title="BatConcurrent" rel="Chapter" href="BatConcurrent.html">
<link title="BatDeque" rel="Chapter" href="BatDeque.html">
<link title="BatDigest" rel="Chapter" href="BatDigest.html">
<link title="BatDllist" rel="Chapter" href="BatDllist.html">
<link title="BatDynArray" rel="Chapter" href="BatDynArray.html">
<link title="BatEnum" rel="Chapter" href="BatEnum.html">
<link title="BatFile" rel="Chapter" href="BatFile.html">
<link title="BatFloat" rel="Chapter" href="BatFloat.html">
<link title="BatFormat" rel="Chapter" href="BatFormat.html">
<link title="BatGc" rel="Chapter" href="BatGc.html">
<link title="BatGenlex" rel="Chapter" href="BatGenlex.html">
<link title="BatGlobal" rel="Chapter" href="BatGlobal.html">
<link title="BatHashcons" rel="Chapter" href="BatHashcons.html">
<link title="BatHashtbl" rel="Chapter" href="BatHashtbl.html">
<link title="BatHeap" rel="Chapter" href="BatHeap.html">
<link title="BatIMap" rel="Chapter" href="BatIMap.html">
<link title="BatIO" rel="Chapter" href="BatIO.html">
<link title="BatISet" rel="Chapter" href="BatISet.html">
<link title="BatInnerIO" rel="Chapter" href="BatInnerIO.html">
<link title="BatInnerWeaktbl" rel="Chapter" href="BatInnerWeaktbl.html">
<link title="BatInt" rel="Chapter" href="BatInt.html">
<link title="BatInt32" rel="Chapter" href="BatInt32.html">
<link title="BatInt64" rel="Chapter" href="BatInt64.html">
<link title="BatInterfaces" rel="Chapter" href="BatInterfaces.html">
<link title="BatLazyList" rel="Chapter" href="BatLazyList.html">
<link title="BatLexing" rel="Chapter" href="BatLexing.html">
<link title="BatList" rel="Chapter" href="BatList.html">
<link title="BatLogger" rel="Chapter" href="BatLogger.html">
<link title="BatMap" rel="Chapter" href="BatMap.html">
<link title="BatMarshal" rel="Chapter" href="BatMarshal.html">
<link title="BatMonad" rel="Chapter" href="BatMonad.html">
<link title="BatMultiPMap" rel="Chapter" href="BatMultiPMap.html">
<link title="BatMutex" rel="Chapter" href="BatMutex.html">
<link title="BatNativeint" rel="Chapter" href="BatNativeint.html">
<link title="BatNum" rel="Chapter" href="BatNum.html">
<link title="BatNumber" rel="Chapter" href="BatNumber.html">
<link title="BatOo" rel="Chapter" href="BatOo.html">
<link title="BatOptParse" rel="Chapter" href="BatOptParse.html">
<link title="BatOption" rel="Chapter" href="BatOption.html">
<link title="BatPMap" rel="Chapter" href="BatPMap.html">
<link title="BatPSet" rel="Chapter" href="BatPSet.html">
<link title="BatPair" rel="Chapter" href="BatPair.html">
<link title="BatParserCo" rel="Chapter" href="BatParserCo.html">
<link title="BatPathGen" rel="Chapter" href="BatPathGen.html">
<link title="BatPervasives" rel="Chapter" href="BatPervasives.html">
<link title="BatPrint" rel="Chapter" href="BatPrint.html">
<link title="BatPrintexc" rel="Chapter" href="BatPrintexc.html">
<link title="BatPrintf" rel="Chapter" href="BatPrintf.html">
<link title="BatQueue" rel="Chapter" href="BatQueue.html">
<link title="BatRMutex" rel="Chapter" href="BatRMutex.html">
<link title="BatRandom" rel="Chapter" href="BatRandom.html">
<link title="BatRef" rel="Chapter" href="BatRef.html">
<link title="BatRefList" rel="Chapter" href="BatRefList.html">
<link title="BatResult" rel="Chapter" href="BatResult.html">
<link title="BatReturn" rel="Chapter" href="BatReturn.html">
<link title="BatRope" rel="Chapter" href="BatRope.html">
<link title="BatScanf" rel="Chapter" href="BatScanf.html">
<link title="BatSeq" rel="Chapter" href="BatSeq.html">
<link title="BatSet" rel="Chapter" href="BatSet.html">
<link title="BatSplay" rel="Chapter" href="BatSplay.html">
<link title="BatStack" rel="Chapter" href="BatStack.html">
<link title="BatStd" rel="Chapter" href="BatStd.html">
<link title="BatStr" rel="Chapter" href="BatStr.html">
<link title="BatStream" rel="Chapter" href="BatStream.html">
<link title="BatString" rel="Chapter" href="BatString.html">
<link title="BatSubstring" rel="Chapter" href="BatSubstring.html">
<link title="BatSys" rel="Chapter" href="BatSys.html">
<link title="BatTuple" rel="Chapter" href="BatTuple.html">
<link title="BatUChar" rel="Chapter" href="BatUChar.html">
<link title="BatUCharParser" rel="Chapter" href="BatUCharParser.html">
<link title="BatUTF8" rel="Chapter" href="BatUTF8.html">
<link title="BatUnit" rel="Chapter" href="BatUnit.html">
<link title="BatUnix" rel="Chapter" href="BatUnix.html">
<link title="BatUref" rel="Chapter" href="BatUref.html">
<link title="BatValue_printer" rel="Chapter" href="BatValue_printer.html">
<link title="BatVect" rel="Chapter" href="BatVect.html">
<link title="Batteries" rel="Chapter" href="Batteries.html">
<link title="Batteries_config" rel="Chapter" href="Batteries_config.html">
<link title="Batteries_print" rel="Chapter" href="Batteries_print.html">
<link title="Batteries_uni" rel="Chapter" href="Batteries_uni.html"><link title="Introduction" rel="Section" href="#6_Introduction">
<link title="Type of formatted input functions" rel="Section" href="#6_Typeofformattedinputfunctions">
<link title="The general formatted input function" rel="Section" href="#6_Thegeneralformattedinputfunction">
<link title="Format string description" rel="Section" href="#6_Formatstringdescription">
<link title="Specialized formatted input functions" rel="Section" href="#6_Specializedformattedinputfunctions">
<link title="Reading format strings from input" rel="Section" href="#6_Readingformatstringsfrominput">
<link title="Functional input with format strings" rel="Subsection" href="#7_Functionalinputwithformatstrings">
<link title="A simple example" rel="Subsection" href="#7_Asimpleexample">
<link title="Formatted input as a functional feature" rel="Subsection" href="#7_Formattedinputasafunctionalfeature">
<link title="The space character in format strings" rel="Subsection" href="#7_Thespacecharacterinformatstrings">
<link title="Conversion specifications in format strings" rel="Subsection" href="#7_Conversionspecificationsinformatstrings">
<link title="Scanning indications in format strings" rel="Subsection" href="#7_Scanningindicationsinformatstrings">
<link title="Exceptions during scanning" rel="Subsection" href="#7_Exceptionsduringscanning">
<title>Batteries_uni.Scanf</title>
</head>
<body>
<div class="navbar"><a href="Batteries_uni.Random.html">Previous</a>
&nbsp;<a href="Batteries_uni.html">Up</a>
&nbsp;<a href="Batteries_uni.Set.html">Next</a>
</div>
<center><h1>Module <a href="type_Batteries_uni.Scanf.html">Batteries_uni.Scanf</a></h1></center>
<br>
<pre><span class="keyword">module</span> Scanf: <code class="type">BatScanf</code></pre><hr width="100%">
<br>
<span id="6_Introduction"><h6>Introduction</h6></span><br>
<br>
<span id="7_Functionalinputwithformatstrings"><div class="h7">Functional input with format strings</div></span><br>
<br>
The module <code class="code">Scanf</code> provides formatted input functions or <em>scanners</em>.
<p>

    The formatted input functions can read from any kind of input, including
    strings, files, or anything that can return characters. The more general
    source of characters is named a <em>scanning buffer</em> and has type
    <a href="BatScanf.Scanning.html#TYPEscanbuf"><code class="code">BatScanf.Scanning.scanbuf</code></a>. The more general formatted input function reads from
    any scanning buffer and is named <code class="code">bscanf</code>.
<p>

    Generally speaking, the formatted input functions have 3 arguments:<ul>
<li>the first argument is a source of characters for the input,</li>
<li>the second argument is a format string that specifies the values to
      read,</li>
<li>the third argument is a <em>receiver function</em> that is applied to the
      values read.</li>
</ul>

    Hence, a typical call to the formatted input function <code class="code">Scanf.bscanf</code> is
    <code class="code">bscanf ib fmt f</code>, where:
<p>
<ul>
<li><code class="code">ib</code> is a source of characters (typically a <em>    scanning buffer</em> with type <a href="BatScanf.Scanning.html#TYPEscanbuf"><code class="code">BatScanf.Scanning.scanbuf</code></a>),</li>
</ul>
<ul>
<li><code class="code">fmt</code> is a format string (the same format strings as those used to print
    material with module <code class="code">Printf</code> or <code class="code">Format</code>),</li>
</ul>
<ul>
<li><code class="code">f</code> is a function that has as many arguments as the number of values to
    read in the input.</li>
</ul>
<br>
<br>
<span id="7_Asimpleexample"><div class="h7">A simple example</div></span><br>
<br>
As suggested above, the expression <code class="code">bscanf ib "%d" f</code> reads a decimal
    integer <code class="code">n</code> from the source of characters <code class="code">ib</code> and returns <code class="code">f n</code>.
<p>

    For instance,
<p>
<ul>
<li>if we use <code class="code">stdib</code> as the source of characters (<a href="BatScanf.Scanning.html#VALstdib"><code class="code">BatScanf.Scanning.stdib</code></a> is
    the predefined input buffer that reads from standard input),</li>
</ul>
<ul>
<li>if we define the receiver <code class="code">f</code> as <code class="code">let f x = x + 1</code>,</li>
</ul>

    then <code class="code">bscanf stdib "%d" f</code> reads an integer <code class="code">n</code> from the standard input
    and returns <code class="code">f n</code> (that is <code class="code">n + 1</code>). Thus, if we evaluate <code class="code">bscanf stdib
    "%d" f</code>, and then enter <code class="code">41</code> at the keyboard, we get <code class="code">42</code> as the final
    result.<br>
<br>
<span id="7_Formattedinputasafunctionalfeature"><div class="h7">Formatted input as a functional feature</div></span><br>
<br>
The Caml scanning facility is reminiscent of the corresponding C feature.
    However, it is also largely different, simpler, and yet more powerful:
    the formatted input functions are higher-order functionals and the
    parameter passing mechanism is just the regular function application not
    the variable assigment based mechanism which is typical for formatted
    input in imperative languages; the Caml format strings also feature
    useful additions to easily define complex tokens; as expected within a
    functional programming language, the formatted input functions also
    support polymorphism, in particular arbitrary interaction with
    polymorphic user-defined scanners.  Furthermore, the Caml formatted input
    facility is fully type-checked at compile time.<br>
<pre><span class="keyword">module</span> <a href="BatScanf.Scanning.html">Scanning</a>: <code class="code">sig</code> <a href="BatScanf.Scanning.html">..</a> <code class="code">end</code></pre><div class="info">
Scanning buffers
</div>
<br>
<span id="6_Typeofformattedinputfunctions"><h6>Type of formatted input functions</h6></span><br>
<pre><span id="TYPEscanner"><span class="keyword">type</span> <code class="type">('a, 'b, 'c, 'd)</code> scanner</span> = <code class="type">('a, <a href="BatScanf.Scanning.html#TYPEscanbuf">Scanning.scanbuf</a>, 'b, 'c, 'a -> 'd, 'd) format6 -> 'c</code> </pre>
<div class="info">
The type of formatted input scanners: <code class="code">('a, 'b, 'c, 'd) scanner</code> is the
    type of a formatted input function that reads from some scanning buffer
    according to some format string; more precisely, if <code class="code">scan</code> is some
    formatted input function, then <code class="code">scan ib fmt f</code> applies <code class="code">f</code> to the arguments
    specified by the format string <code class="code">fmt</code>, when <code class="code">scan</code> has read those arguments
    from the scanning input buffer <code class="code">ib</code>.
<p>

    For instance, the <code class="code">scanf</code> function below has type <code class="code">('a, 'b, 'c, 'd)
    scanner</code>, since it is a formatted input function that reads from <code class="code">stdib</code>:
    <code class="code">scanf fmt f</code> applies <code class="code">f</code> to the arguments specified by <code class="code">fmt</code>, reading
    those arguments from <code class="code">stdin</code> as expected.
<p>

    If the format <code class="code">fmt</code> has some <code class="code">%r</code> indications, the corresponding input
    functions must be provided before the receiver <code class="code">f</code> argument. For
    instance, if <code class="code">read_elem</code> is an input function for values of type <code class="code">t</code>,
    then <code class="code">bscanf ib "%r;" read_elem f</code> reads a value <code class="code">v</code> of type <code class="code">t</code> followed
    by a <code class="code">';'</code> character, and returns <code class="code">f v</code>.<br>
</div>

<pre><span id="EXCEPTIONScan_failure"><span class="keyword">exception</span> Scan_failure</span> <span class="keyword">of</span> <code class="type">string</code></pre>
<div class="info">
The exception that formatted input functions raise when the input cannot be
    read according to the given format.<br>
</div>
<br>
<span id="6_Thegeneralformattedinputfunction"><h6>The general formatted input function</h6></span><br>
<pre><span id="VALbscanf"><span class="keyword">val</span> bscanf</span> : <code class="type"><a href="BatScanf.Scanning.html#TYPEscanbuf">Scanning.scanbuf</a> -> ('a, 'b, 'c, 'd) <a href="BatScanf.html#TYPEscanner">scanner</a></code></pre><div class="info">
<code class="code">bscanf ib fmt r1 ... rN f</code> reads arguments for the function <code class="code">f</code>, from the
    scanning buffer <code class="code">ib</code>, according to the format string <code class="code">fmt</code>, and applies <code class="code">f</code>
    to these values.
    The result of this call to <code class="code">f</code> is returned as the result of the entire
    <code class="code">bscanf</code> call.
    For instance, if <code class="code">f</code> is the function <code class="code">fun s i -&gt; i + 1</code>, then
    <code class="code">Scanf.sscanf "x=  1" "%s = %i" f</code> returns <code class="code">2</code>.
<p>

    Arguments <code class="code">r1</code> to <code class="code">rN</code> are user-defined input functions that read the
    argument corresponding to a <code class="code">%r</code> conversion.<br>
</div>
<br>
<span id="6_Formatstringdescription"><h6>Format string description</h6></span><br>
<br>
The format is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input,</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code>,</li>
<li>scanning indications to specify boundaries of tokens.</li>
</ul>
<br>
<br>
<span id="7_Thespacecharacterinformatstrings"><div class="h7">The space character in format strings</div></span><br>
<br>
As mentioned above, a plain character in the format string is just
    matched with the characters of the input; however, one character is a
    special exception to this simple rule: the space character (ASCII code
    32) does not match a single space character, but any amount of
    ``whitespace'' in the input. More precisely, a space inside the format
    string matches <em>any number</em> of tab, space, line feed and carriage
    return characters.
<p>

    Matching <em>any</em> amount of whitespace, a space in the format string
    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib
    "Price = %d $" (fun p -&gt; p)</code> succeds and returns <code class="code">1</code> when reading an
    input with various whitespace in it, such as <code class="code">Price = 1 $</code>,
    <code class="code">Price  =  1    $</code>, or even <code class="code">Price=1$</code>.<br>
<br>
<span id="7_Conversionspecificationsinformatstrings"><div class="h7">Conversion specifications in format strings</div></span><br>
<br>
Conversion specifications consist in the <code class="code">%</code> character, followed by
    an optional flag, an optional field width, and followed by one or
    two conversion characters. The conversion characters and their
    meanings are:
<p>
<ul>
<li><code class="code">d</code>: reads an optionally signed decimal integer.</li>
<li><code class="code">i</code>: reads an optionally signed integer
      (usual input formats for hexadecimal (<code class="code">0x[d]+</code> and <code class="code">0X[d]+</code>),
       octal (<code class="code">0o[d]+</code>), and binary <code class="code">0b[d]+</code> notations are understood).</li>
<li><code class="code">u</code>: reads an unsigned decimal integer.</li>
<li><code class="code">x</code> or <code class="code">X</code>: reads an unsigned hexadecimal integer.</li>
<li><code class="code">o</code>: reads an unsigned octal integer.</li>
<li><code class="code">s</code>: reads a string argument that spreads as much as possible, until the
      following bounding condition holds: a whitespace has been found, a
      scanning indication has been encountered, or the end-of-input has been
      reached.
      Hence, this conversion always succeeds: it returns an empty
      string, if the bounding condition holds when the scan begins.</li>
<li><code class="code">S</code>: reads a delimited string argument (delimiters and special
      escaped characters follow the lexical conventions of Caml).</li>
<li><code class="code">c</code>: reads a single character. To test the current input character
      without reading it, specify a null field width, i.e. use
      specification <code class="code">%0c</code>. Raise <code class="code">Invalid_argument</code>, if the field width
      specification is greater than 1.</li>
<li><code class="code">C</code>: reads a single delimited character (delimiters and special
      escaped characters follow the lexical conventions of Caml).</li>
<li><code class="code">f</code>, <code class="code">e</code>, <code class="code">E</code>, <code class="code">g</code>, <code class="code">G</code>: reads an optionally signed
      floating-point number in decimal notation, in the style <code class="code">dddd.ddd
      e/E+-dd</code>.</li>
<li><code class="code">F</code>: reads a floating point number according to the lexical
      conventions of Caml (hence the decimal point is mandatory if the
      exponent part is not mentioned).</li>
<li><code class="code">B</code>: reads a boolean argument (<code class="code">true</code> or <code class="code">false</code>).</li>
<li><code class="code">b</code>: reads a boolean argument (for backward compatibility; do not use
      in new programs).</li>
<li><code class="code">ld</code>, <code class="code">li</code>, <code class="code">lu</code>, <code class="code">lx</code>, <code class="code">lX</code>, <code class="code">lo</code>: reads an <code class="code">int32</code> argument to
      the format specified by the second letter (decimal, hexadecimal, etc).</li>
<li><code class="code">nd</code>, <code class="code">ni</code>, <code class="code">nu</code>, <code class="code">nx</code>, <code class="code">nX</code>, <code class="code">no</code>: reads a <code class="code">nativeint</code> argument to
      the format specified by the second letter.</li>
<li><code class="code">Ld</code>, <code class="code">Li</code>, <code class="code">Lu</code>, <code class="code">Lx</code>, <code class="code">LX</code>, <code class="code">Lo</code>: reads an <code class="code">int64</code> argument to
      the format specified by the second letter.</li>
<li><code class="code">[ range ]</code>: reads characters that matches one of the characters
      mentioned in the range of characters <code class="code">range</code> (or not mentioned in
      it, if the range starts with <code class="code">^</code>). Reads a <code class="code">string</code> that can be
      empty, if the next input character does not match the range. The set of
      characters from <code class="code">c1</code> to <code class="code">c2</code> (inclusively) is denoted by <code class="code">c1-c2</code>.
      Hence, <code class="code">%[0-9]</code> returns a string representing a decimal number
      or an empty string if no decimal digit is found; similarly,
      <code class="code">%[\\048-\\057\\065-\\070]</code> returns a string of hexadecimal digits.
      If a closing bracket appears in a range, it must occur as the
      first character of the range (or just after the <code class="code">^</code> in case of
      range negation); hence <code class="code">[]]</code> matches a <code class="code">]</code> character and
      <code class="code">[^]]</code> matches any character that is not <code class="code">]</code>.</li>
<li><code class="code">r</code>: user-defined reader. Takes the next <code class="code">ri</code> formatted input function and
      applies it to the scanning buffer <code class="code">ib</code> to read the next argument. The
      input function <code class="code">ri</code> must therefore have type <code class="code">Scanning.scanbuf -&gt; 'a</code> and
      the argument read has type <code class="code">'a</code>.</li>
<li><code class="code">{ fmt %}</code>: reads a format string argument.
      The format string read must have the same type as the format string
      specification <code class="code">fmt</code>.
      For instance, <code class="code">"%{%i%}"</code> reads any format string that can read a value of
      type <code class="code">int</code>; hence <code class="code">Scanf.sscanf "fmt:\\\"number is %u\\\"" "fmt:%{%i%}"</code>
      succeeds and returns the format string <code class="code">"number is %u"</code>.</li>
<li><code class="code">\( fmt %\)</code>: scanning format substitution.
      Reads a format string to replace <code class="code">fmt</code>.
      The format string read must have the same type as the format string
      specification <code class="code">fmt</code>.
      For instance, <code class="code">"%\( %i% \)"</code> reads any format string that can read a value
      of type <code class="code">int</code>; hence <code class="code">Scanf.sscanf "\\\"%4d\\\"1234.00" "%\(%i%\)"</code>
      is equivalent to <code class="code">Scanf.sscanf "1234.00" "%4d"</code>.</li>
<li><code class="code">l</code>: returns the number of lines read so far.</li>
<li><code class="code">n</code>: returns the number of characters read so far.</li>
<li><code class="code">N</code> or <code class="code">L</code>: returns the number of tokens read so far.</li>
<li><code class="code">!</code>: matches the end of input condition.</li>
<li><code class="code">%</code>: matches one <code class="code">%</code> character in the input.</li>
</ul>

    Following the <code class="code">%</code> character that introduces a conversion, there may be
    the special flag <code class="code">_</code>: the conversion that follows occurs as usual,
    but the resulting value is discarded.
    For instance, if <code class="code">f</code> is the function <code class="code">fun i -&gt; i + 1</code>, then
    <code class="code">Scanf.sscanf "x = 1" "%_s = %i" f</code> returns <code class="code">2</code>.
<p>

    The field width is composed of an optional integer literal
    indicating the maximal width of the token to read.
    For instance, <code class="code">%6d</code> reads an integer, having at most 6 decimal digits;
    <code class="code">%4f</code> reads a float with at most 4 characters; and <code class="code">%8[\\000-\\255]</code>
    returns the next 8 characters (or all the characters still available,
    if fewer than 8 characters are available in the input).
<p>

    Notes:
<p>
<ul>
<li>as mentioned above, a <code class="code">%s</code> convertion always succeeds, even if there is
      nothing to read in the input: it simply returns <code class="code">""</code>.</li>
</ul>
<ul>
<li>in addition to the relevant digits, <code class="code">'_'</code> characters may appear
    inside numbers (this is reminiscent to the usual Caml lexical
    conventions). If stricter scanning is desired, use the range
    conversion facility instead of the number conversions.</li>
</ul>
<ul>
<li>the <code class="code">scanf</code> facility is not intended for heavy duty lexical
    analysis and parsing. If it appears not expressive enough for your
    needs, several alternative exists: regular expressions (module
    <code class="code">Str</code>), stream parsers, <code class="code">ocamllex</code>-generated lexers,
    <code class="code">ocamlyacc</code>-generated parsers.</li>
</ul>
<br>
<br>
<span id="7_Scanningindicationsinformatstrings"><div class="h7">Scanning indications in format strings</div></span><br>
<br>
Scanning indications appear just after the string conversions <code class="code">%s</code>
    and <code class="code">%[ range ]</code> to delimit the end of the token. A scanning
    indication is introduced by a <code class="code">@</code> character, followed by some
    constant character <code class="code">c</code>. It means that the string token should end
    just before the next matching <code class="code">c</code> (which is skipped). If no <code class="code">c</code>
    character is encountered, the string token spreads as much as
    possible. For instance, <code class="code">"%s@\t"</code> reads a string up to the next
    tab character or to the end of input. If a scanning
    indication <code class="code">@c</code> does not follow a string conversion, it is treated
    as a plain <code class="code">c</code> character.
<p>

    Note:
<p>
<ul>
<li>the scanning indications introduce slight differences in the syntax of
    <code class="code">Scanf</code> format strings, compared to those used for the <code class="code">Printf</code>
    module. However, the scanning indications are similar to those used in
    the <code class="code">Format</code> module; hence, when producing formatted text to be scanned
    by <code class="code">!Scanf.bscanf</code>, it is wise to use printing functions from the
    <code class="code">Format</code> module (or, if you need to use functions from <code class="code">Printf</code>, banish
    or carefully double check the format strings that contain <code class="code">'@'</code>
    characters).</li>
</ul>
<br>
<br>
<span id="7_Exceptionsduringscanning"><div class="h7">Exceptions during scanning</div></span><br>
<br>
Scanners may raise the following exceptions when the input cannot be read
    according to the format string:
<p>
<ul>
<li>Raise <code class="code">Scanf.Scan_failure</code> if the input does not match the format.</li>
</ul>
<ul>
<li>Raise <code class="code">Failure</code> if a conversion to a number is not possible.</li>
</ul>
<ul>
<li>Raise <code class="code">End_of_file</code> if the end of input is encountered while some more
      characters are needed to read the current conversion specification.</li>
</ul>
<ul>
<li>Raise <code class="code">Invalid_argument</code> if the format string is invalid.</li>
</ul>

    Note:
<p>
<ul>
<li>as a consequence, scanning a <code class="code">%s</code> conversion never raises exception
    <code class="code">End_of_file</code>: if the end of input is reached the conversion succeeds and
    simply returns the characters read so far, or <code class="code">""</code> if none were read.</li>
</ul>
<br>
<br>
<span id="6_Specializedformattedinputfunctions"><h6>Specialized formatted input functions</h6></span><br>
<pre><span id="VALfscanf"><span class="keyword">val</span> fscanf</span> : <code class="type">Pervasives.in_channel -> ('a, 'b, 'c, 'd) <a href="BatScanf.html#TYPEscanner">scanner</a></code></pre><div class="info">
Same as <code class="code">Scanf.bscanf</code>, but reads from the given channel.
<p>

    Warning: since all formatted input functions operate from a scanning
    buffer, be aware that each <code class="code">fscanf</code> invocation will operate with a
    scanning buffer reading from the given channel. This extra level of
    bufferization can lead to strange scanning behaviour if you use low level
    primitives on the channel (reading characters, seeking the reading
    position, and so on).
<p>

    As a consequence, never mixt direct low level reading and high level
    scanning from the same input channel.<br>
</div>
<pre><span id="VALsscanf"><span class="keyword">val</span> sscanf</span> : <code class="type">string -> ('a, 'b, 'c, 'd) <a href="BatScanf.html#TYPEscanner">scanner</a></code></pre><div class="info">
Same as <code class="code">Scanf.bscanf</code>, but reads from the given string.<br>
</div>
<pre><span id="VALscanf"><span class="keyword">val</span> scanf</span> : <code class="type">('a, 'b, 'c, 'd) <a href="BatScanf.html#TYPEscanner">scanner</a></code></pre><div class="info">
Same as <code class="code">Scanf.bscanf</code>, but reads from the predefined scanning
    buffer <code class="code">Scanf.Scanning.stdib</code> that is connected to <code class="code">stdin</code>.<br>
</div>
<pre><span id="VALkscanf"><span class="keyword">val</span> kscanf</span> : <code class="type"><a href="BatScanf.Scanning.html#TYPEscanbuf">Scanning.scanbuf</a> -><br>       (<a href="BatScanf.Scanning.html#TYPEscanbuf">Scanning.scanbuf</a> -> exn -> 'a) -> ('b, 'c, 'd, 'a) <a href="BatScanf.html#TYPEscanner">scanner</a></code></pre><div class="info">
Same as <code class="code">Scanf.bscanf</code>, but takes an additional function argument
    <code class="code">ef</code> that is called in case of error: if the scanning process or
    some conversion fails, the scanning function aborts and calls the
    error handling function <code class="code">ef</code> with the scanning buffer and the
    exception that aborted the scanning process.<br>
</div>
<br>
<span id="6_Readingformatstringsfrominput"><h6>Reading format strings from input</h6></span><br>
<pre><span id="VALbscanf_format"><span class="keyword">val</span> bscanf_format</span> : <code class="type"><a href="BatScanf.Scanning.html#TYPEscanbuf">Scanning.scanbuf</a> -><br>       ('a, 'b, 'c, 'd, 'e, 'f) format6 -><br>       (('a, 'b, 'c, 'd, 'e, 'f) format6 -> 'g) -> 'g</code></pre><div class="info">
<code class="code">bscanf_format ib fmt f</code> reads a format string token from the scannning
    buffer <code class="code">ib</code>, according to the given format string <code class="code">fmt</code>, and applies <code class="code">f</code> to
    the resulting format string value.
    Raise <code class="code">Scan_failure</code> if the format string value read does not have the
    same type as <code class="code">fmt</code>.<br>
</div>
<pre><span id="VALsscanf_format"><span class="keyword">val</span> sscanf_format</span> : <code class="type">string -><br>       ('a, 'b, 'c, 'd, 'e, 'f) format6 -><br>       (('a, 'b, 'c, 'd, 'e, 'f) format6 -> 'g) -> 'g</code></pre><div class="info">
Same as <code class="code">Scanf.bscanf_format</code>, but reads from the given string.<br>
</div>
<pre><span id="VALformat_from_string"><span class="keyword">val</span> format_from_string</span> : <code class="type">string -><br>       ('a, 'b, 'c, 'd, 'e, 'f) format6 -> ('a, 'b, 'c, 'd, 'e, 'f) format6</code></pre><div class="info">
<code class="code">format_from_string s fmt</code> converts a string argument to a format string,
    according to the given format string <code class="code">fmt</code>.
    Raise <code class="code">Scan_failure</code> if <code class="code">s</code>, considered as a format string, does not
    have the same type as <code class="code">fmt</code>.<br>
</div>
</body></html>