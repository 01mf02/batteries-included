<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="root.html">
<link title="Index of modules" rel=Appendix href="root_modules.html">
<link title="Batteries" rel="Chapter" href="Batteries.html"><title>OCaml Batteries Included</title>
</head>
<body>
<center><h1>Language extensions introduced in Batteries Included</h1></center>
Several language extensions and convenience features are introduced in Batteries Included.
To take advantage of these features, please see <a href="setup.html">the corresponding chapter</a>.
Note that most of these extensions were not developed specifically for Batteries Included and may
be used separately.

<center><h2>Opening of modules</h2></center>
<center>(activated by default, implemented as findlib package <code>batteries.pa_openin.syntax</code>)</center>
<center><h3>Local opening of modules</h3></center>
<center>(forked from <a href="http://alain.frisch.fr/soft.html">openin</a>)</center>
You can open local modules, inside an expression if needed.
<br />
For instance:
<pre class="example">
open System.File in
 (*Here, System.File is opened*)
 lines_of "some_file"

(*Here, System.File is not opened anymore*)
</pre>
These modules do not need to be named. For instance, you may write
<pre class="example">
open Hashtbl.Make(String) in
 (*...*)
</pre>


<center><h3>Initialization of modules</h3></center>
<center>(designed for Batteries)</center>
As a convenience, you can specify an expression to be evaluated when opening a module.
For instance,
<pre class="example">
open Util.Random with self_init ()
</pre>
This extract is equivalent to
<pre class="example">
open Util.Random
let _ = self_init ()
</pre>
This feature is provided as it may sometimes increase readability.

<center><h3>Opening several modules</h3></center>
<center>(designed for Batteries)</center>
As a convenience, you can specify a comma-separated list of modules to be opened in one operation.
Consider for instance
<pre class="example">
open Data.Mutable, Data.Persistent
</pre>
This extract is equivalent to
<pre class="example">
open Data.Mutable
open Data.Persistent
</pre>

This feature is provided as it may sometimes increase readability.

<center><h3>Aliasing several modules to one name<a name="#multialias"/></h3></center>
<center>(designed for Batteries)</center>
As a convenience, you can specify that a module name should serve to
represent the union of several modules. Consider for instance
<pre class="example">
module E = Data.Mutable.Enum include ExceptionLess, Labels
</pre>
This extract defines a local module name <code>E</code>
with all the values and types of modules <code>Enum</code>,
<code>ExceptionLess</code> and <code>Labels</code>. In
particular, some values defined in <code>Enum</code>
may be overridden with values defined in <code>ExceptionLess</code>
and/or <code>Labels</code>. 


<pre class="example">
module Enum =
struct
 include Enum
 include ExceptionLess
 include Labels
end
</pre>

This feature is provided as it may sometimes increase readability.

<br />

One of the main uses of this feature is to permit opening in one
operation modules which define some functions and modules which
override these functions.  This is the case of module <code>IO</code>,
which defines operations for input and output: this module contains a
submodule <code>BigEndian</code>, which defines operations which
should be used to communicate with specific architectures. One of these
functions is <code>read_float</code>: <code>IO.read_float</code> is
adapted to small-endian architectures, while <code>IO.BigEndian.read_float</code>
is adapted to big-endian architectures

The
functions of <code>BigEndian</code> have the same name as functions
of <code>IO</code>.  The following extract will therefore open
both <code>IO</code> and <code>BigEndian</code> in one operation:
<pre class="example">
open IO, BigEndian
</pre>


This extract is equivalent to
<pre class="example">
open Data.Mutable
open Data.Persistent
</pre>


<center><h2>"where" construction<a name = "where"/></h2></center>
<center>(activated by default, implemented as findlib package <code>batteries.pa_where.syntax</code>)</center>
<center>(part of <a href="http://forge.ocamlcore.org/projects/pa-where/">pa_where</a>, distributed with Batteries)</center>

By default, OCaml provides a construction <code>let...in...</code>. This extension adds
a dual construction <code>... where ...</code>, once again, to increase readability
when appropriate. 
<br />
Where <code>let...in...</code> lets you define a value and use it immediately,
<code>... where...</code> lets you use a value and define it immediately, as
is often done in mathematic notations. Consider
<pre class="example">
let fibo n = fst fibo_aux n
  where rec fibo_aux = function
    | 0 -> (1, 1)
    | 1 -> (1, 2)
    | n -> (a, a + b) where let (a, b) = fibo_aux ( n - 1 )
</pre>
This extract is equivalent to
<pre class="example">
let fibo n =
  let rec fibo_aux =
    function
    | 0 -> (1, 1)
    | 1 -> (1, 2)
    | n -> let (a, b) = fibo_aux (n - 1) in (a, (a + b))
  in fst (fibo_aux n)
</pre>

More generally, <code>&lt;expression&gt; where &lt;definitions&gt;</code>
is equivalent to <code>let &lt;definitions&gt; in &lt;expression&gt;</code>.
Note that you can define (mutually) recursive functions with <code>where</code>
just as well as with <code>let</code>.
<br />
As a convenience, you may wrote <code>where let</code> instead of <code>where</code>.


<dl>
<dt>Associativity</dt><dd> <code>a where b where c</code> is equivalent to <code>(a where b) where c</code></dd>
<dt>Precedence</dt><dd> <code>let a = b where c and d</code> is equivalent to <code>let a = (b where c and d)</code></dd>
</dl>


<center><h2>Comprehension expressions</h2></center>
<center>(activated by default, implemented as findlib package <code>batteries.pa_comprehension.syntax</code>)</center>
<center>(designed for Batteries)</center>

A <a href="http://en.wikipedia.org/wiki/List_comprehension">list
comprehension syntax</a> for batteries, using enumerations by default.

<center><h3>Output, generators and guards</h3></center>

<p>The global form is
<code>[? <em>output</em> | <em>comp_item</em> ; <em>comp_item</em> ; ... ]</code>.<br/>
<em>output</em> is an expression and a <em>comp_item</em> is either
a <em>guard</em> (a boolean expression), or a <em>generator</em> of
the form <code><em>pattern</em> <- <em>expression</em></code>.
Variables bound in the pattern can be used in the following
comprehension items, and in the output expression.</p>

Example :
<pre class="example">let pythagorean_triples n =
  [? (a,b,c) | a <- 1--n; b <- a--n; c <- b--n; a*a + b*b = c*c ]</pre>

<center><h3>Module parametrization</h3></center>

<p>By default, the output in an enumeration, and generator expressions
are assumed to be enumerations. It is possible to choose a different
data structure with the <code><em>module</em> : <em>expression</em></code> syntax.</p>

Examples :
<pre class="example">let positive_array_of_enum e =
  [? Array : n | n <- e; n > 0 ]

let combine la lb =
  [? List : (a, b) | a <- List : la; b <- List : lb ]</pre>

<p>Comprehension expressions rely on the presence in the given module of
the following operations (where <code>'a t</code> represents the
data-structure type : <code>'a array</code>, <code>'a
Enum.t</code>...) :</p>
<pre>
val filter : ('a -> bool) -> 'a t -> 'a t
val concat : 'a t t -> 'a t
val map : ('a -> 'b) -> 'a t -> 'b t
val filter_map : ('a -> 'b option) -> 'a t -> 'b t (* used for refutable patterns in generators *)

val enum : 'a t -> 'a Enum.t
val of_enum : 'a Enum.t -> 'a t
</pre>

<p>If your module does not provide the first four operations but only
the enum conversion functions, you could still benefit from the
comprehension syntax by using eg. <code>foo <- Mod.enum bar</code> instead
of <code>foo <- Mod : bar</code>.</p>

<center><h2>Boilerplate construction</h2></center>
<center>(<i>de</i>activated by default, implemented as findlib package <code>sexplib.syntax</code>)</center>

<center><h3>Serialization to S-Expressions</h3></center> 
<center>(feature provided by <a href="http://www.ocaml.info/home/ocaml_sources.html">Sexplib</a>)</center>
S-Expressions are a human-readable format for the transmission and
storage of data, comparable to JSON. 
<br />
A new construction <code>with sexp</code> is added to type
definitions. This construction may be used to automatically (or
semi-automatically, if need arises) generate functions to transform
values into S-Expressions.
<br />
Let us consider the following extract:
<pre class="example">
TYPE_CONV_PATH "Current.Module.Name" (*Required*)

type color = Spade
           | Heart
           | Club
           | Diamond        with sexp

type value = Number of int
           | Ace
           | King
           | Queen
           | Jack           with sexp

type card = color * value   with sexp
</pre>
This extract defines types <code>color</code>, <code>value</code> and <code>card</code>,
as well as functions:
<pre class="example">
val sexp_of_color: color -> Batteries.Languages.SExpr.t
val color_of_sexp: Batteries.Languages.SExpr.t -> color

val sexp_of_value: value -> Batteries.Languages.SExpr.t
val value_of_sexp: Batteries.Languages.SExpr.t -> value

val sexp_of_card : card -> Batteries.Languages.SExpr.t
val card_of_sexp : Batteries.Languages.SExpr.t -> card
</pre>
<br />
Module <a href="api/Batteries.Languages.SExpr.html">Languages.SExpr</a>
may be used to manipulate S-Expressions, to save them to files, load
them from files, display them...
<br />
Most of the types known to Batteries Included are compatible with
<code>with sexp</code>. If you encounter a type which is not compatible 
with this boilerplate generator, you may define manually functions
<code>sexp_of_foo</code> and <code>foo_of_sexp</code>. These functions
will integrate nicely with the rest of S-Expressions.
<br />
For more information, see the manual of <a href="http://www.ocaml.info/ocaml_sources/sexplib310-4.2.0/README.txt">Sexplib</a>

<center><h1>Summary of new keywords</h1></center>
<ul>
<li><code>where</code>, <a href="#where">defined by pa_where</a></li>
</ul>

</body>
</html>
